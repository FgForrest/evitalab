// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file GrpcPrice.proto (package io.evitadb.externalApi.grpc.generated, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Int32Value, Message, proto3 } from "@bufbuild/protobuf";
import { GrpcBigDecimal, GrpcCurrency, GrpcDateTimeRange } from "./GrpcEvitaDataTypes_pb.js";

/**
 * Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce systems
 * and highly affects performance of the entities filtering and sorting, they deserve first class support in entity model.
 * It is pretty common in B2B systems single product has assigned dozens of prices for the different customers.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcPrice
 */
export class GrpcPrice extends Message<GrpcPrice> {
  /**
   * Contains identification of the price in the external systems. This id is expected to be used for the synchronization
   * of the price in relation with the primary source of the prices.
   * This id is used to uniquely find a price within same price list and currency and is mandatory.
   *
   * @generated from field: int32 priceId = 1;
   */
  priceId = 0;

  /**
   * Contains identification of the price list in the external system. Each price must reference a price list. Price list
   * identification may refer to another Evita entity or may contain any external price list identification
   * (for example id or unique name of the price list in the external system).
   * Single entity is expected to have single price for the price list unless there is validity specified.
   * In other words there is no sense to have multiple concurrently valid prices for the same entity that have roots
   * in the same price list.
   *
   * @generated from field: string priceList = 2;
   */
  priceList = "";

  /**
   * Identification of the currency.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcCurrency currency = 3;
   */
  currency?: GrpcCurrency;

  /**
   * Some special products (such as master products, or product sets) may contain prices of all "subordinate" products
   * so that the aggregating product can represent them in certain views on the product. In that case there is need
   * to distinguish the projected prices of the subordinate product in the one that represents them.
   * Inner record id must contain positive value.
   *
   * @generated from field: google.protobuf.Int32Value innerRecordId = 4;
   */
  innerRecordId?: number;

  /**
   * Price without tax.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcBigDecimal priceWithoutTax = 5;
   */
  priceWithoutTax?: GrpcBigDecimal;

  /**
   * Price with tax.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcBigDecimal taxRate = 6;
   */
  taxRate?: GrpcBigDecimal;

  /**
   * Tax rate percentage (i.e. for 19% it'll be 19.00)
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcBigDecimal priceWithTax = 7;
   */
  priceWithTax?: GrpcBigDecimal;

  /**
   * Date and time interval for which the price is valid (inclusive).
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcDateTimeRange validity = 8;
   */
  validity?: GrpcDateTimeRange;

  /**
   * Controls whether price is subject to filtering / sorting logic, non-sellable prices will be fetched along with
   * entity but won't be considered when evaluating search. These prices may be
   * used for "informational" prices such as reference price (the crossed out price often found on e-commerce sites
   * as "usual price") but are not considered as the "selling" price.
   * RENAMED TO "indexed"
   *
   * @generated from field: bool sellable = 9 [deprecated = true];
   * @deprecated
   */
  sellable = false;

  /**
   * Contains version of this price and gets increased with any entity type update. Allows to execute
   * optimistic locking i.e. avoiding parallel modifications.
   *
   * @generated from field: int32 version = 10;
   */
  version = 0;

  /**
   * Controls whether price is subject to filtering / sorting logic, non-sellable prices will be fetched along with
   * entity but won't be considered when evaluating search. These prices may be
   * used for "informational" prices such as reference price (the crossed out price often found on e-commerce sites
   * as "usual price") but are not considered as the "selling" price.
   *
   * @generated from field: bool indexed = 11;
   */
  indexed = false;

  constructor(data?: PartialMessage<GrpcPrice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcPrice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "priceId", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "priceList", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "currency", kind: "message", T: GrpcCurrency },
    { no: 4, name: "innerRecordId", kind: "message", T: Int32Value },
    { no: 5, name: "priceWithoutTax", kind: "message", T: GrpcBigDecimal },
    { no: 6, name: "taxRate", kind: "message", T: GrpcBigDecimal },
    { no: 7, name: "priceWithTax", kind: "message", T: GrpcBigDecimal },
    { no: 8, name: "validity", kind: "message", T: GrpcDateTimeRange },
    { no: 9, name: "sellable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "indexed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcPrice {
    return new GrpcPrice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcPrice {
    return new GrpcPrice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcPrice {
    return new GrpcPrice().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcPrice | PlainMessage<GrpcPrice> | undefined, b: GrpcPrice | PlainMessage<GrpcPrice> | undefined): boolean {
    return proto3.util.equals(GrpcPrice, a, b);
  }
}

