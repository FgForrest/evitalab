// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file GrpcEntitySchema.proto (package io.evitadb.externalApi.grpc.generated, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, StringValue } from "@bufbuild/protobuf";
import { GrpcCurrency, GrpcEvitaValue, GrpcLocale, GrpcNameVariant } from "./GrpcEvitaDataTypes_pb.js";
import { GrpcAttributeInheritanceBehavior, GrpcAttributeSchemaType, GrpcAttributeUniquenessType, GrpcCardinality, GrpcEvitaAssociatedDataDataType_GrpcEvitaDataType, GrpcEvitaDataType, GrpcEvolutionMode, GrpcGlobalAttributeUniquenessType, GrpcOrderBehaviour, GrpcOrderDirection } from "./GrpcEnums_pb.js";

/**
 * This is the definition object for entity. Definition objects allow to describe the structure
 * of the entity type so that in any time everyone can consult complete structure of the entity type.
 *
 * Based on our experience we've designed following data model for handling entities in evitaDB. Model is rather complex
 * but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject
 * to search.
 *
 * Minimal entity definition consists of:
 * - entity type and
 * - primary key (even this is optional and may be autogenerated by the database).
 *
 * Other entity data is purely optional and may not be used at all.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcEntitySchema
 */
export class GrpcEntitySchema extends Message<GrpcEntitySchema> {
  /**
   * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains version of this entity schema and gets increased with any entity type update. Allows to execute
   * optimistic locking i.e. avoiding parallel modifications.
   *
   * @generated from field: int32 version = 2;
   */
  version = 0;

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 3;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this entity from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * If notice is `null`, this schema is considered not deprecated.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 4;
   */
  deprecationNotice?: string;

  /**
   * Contains `true` when primary keys of entities of this type will not be provided by the external systems and Evita
   * is responsible for generating unique primary keys for the entity on insertion.
   *
   * Generated key is guaranteed to be unique, but may not represent continuous ascending series. Generated key
   * will be always greater than zero.
   *
   * @generated from field: bool withGeneratedPrimaryKey = 5;
   */
  withGeneratedPrimaryKey = false;

  /**
   * Contains `true` when entities of this type are organized in a tree like structure (hierarchy) where certain entities
   * are subordinate of other entities.
   *
   * Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be
   * referred by multiple child entities. Hierarchy is always composed of entities of same type.
   * Each entity must be part of at most single hierarchy (tree).
   *
   * Hierarchy can limit returned entities by using filtering constraints. It's also used for
   * computation of extra data - such as `hierarchyParentsOfSelf`. It can also invert type of returned entities in case extra result
   * `hierarchyOfSelf` is requested.
   *
   * @generated from field: bool withHierarchy = 6;
   */
  withHierarchy = false;

  /**
   * Contains `true` when entities of this type holds price information.
   *
   * Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce
   * systems and highly affects performance of the entities filtering and sorting, they deserve first class support
   * in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different
   * customers.
   *
   * Specifying prices on entity allows usage of `priceValidIn`, `priceInCurrency`
   * `priceBetween`, and `priceInPriceLists` filtering constraints and also `priceNatural`,
   * ordering of the entities. Additional extra result
   * `priceHistogram` and requirement `priceType` can be used in query as well.
   *
   * @generated from field: bool withPrice = 7;
   */
  withPrice = false;

  /**
   * Determines how many fractional places are important when entities are compared during filtering or sorting. It is
   * important to know that all prices will be converted to `Int`, so any of the price values
   * (either with or without tax) must not ever exceed maximum limits of `Int` type when scaling
   * the number by the power of ten using `indexedPricePlaces` as exponent.
   *
   * @generated from field: int32 indexedPricePlaces = 8;
   */
  indexedPricePlaces = 0;

  /**
   * Contains set of all `Locale` that could be used for localized `AttributeSchema` or `AssociatedDataSchema`.
   * Enables using `entityLocaleEquals` filtering constraint in query.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcLocale locales = 9;
   */
  locales: GrpcLocale[] = [];

  /**
   * Contains set of all `Currency` that could be used for `prices` in entities of this type.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcCurrency currencies = 10;
   */
  currencies: GrpcCurrency[] = [];

  /**
   * Contains index of all `AttributeSchema` that could be used as attributes of entity of this type.
   *
   * Entity (global) attributes allows defining set of data that are fetched in bulk along with the entity body.
   * Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
   * (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
   * memory space for data that will never be used in search queries.
   *
   * Filtering in attributes is executed by using constraints like `and`,
   * `not`, `attributeEquals`, `attributeContains`
   * and many others. Sorting can be achieved with `attributeNatural` or others.
   *
   * Attributes are not recommended for bigger data as they are all loaded at once requested.
   * Large data that are occasionally used store in `associatedData`.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcAttributeSchema> attributes = 11;
   */
  attributes: { [key: string]: GrpcAttributeSchema } = {};

  /**
   * Contains index of all `AssociatedDataSchema` that could be used as associated data of entity of this type.
   *
   * Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
   * along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
   * in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
   * binary arrays representing entire files (i.e. pictures, documents).
   *
   * The search query must contain specific associated data fields in order
   * associated data are fetched along with the entity. Associated data are stored and fetched separately by their name.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcAssociatedDataSchema> associatedData = 12;
   */
  associatedData: { [key: string]: GrpcAssociatedDataSchema } = {};

  /**
   * Contains index of all `ReferenceSchema` that could be used as references of entity of this type.
   *
   * References refer to other entities (of same or different entity type).
   * Allows entity filtering (but not sorting) of the entities by using `facetInSet` constraint
   * and statistics computation when `facetStatistics` extra result is requested. Reference
   * is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
   * part of multiple reference groups, that are also represented by int and entity type.
   *
   * Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
   * of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
   * to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
   * group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
   * Evita.
   *
   * References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
   * The search query must contain specific `referenceContent` requirement in order
   * references are fetched along with the entity.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcReferenceSchema> references = 13;
   */
  references: { [key: string]: GrpcReferenceSchema } = {};

  /**
   * Evolution mode allows to specify how strict is evitaDB when unknown information is presented to her for the first
   * time. When no evolution mode is set, each violation of the `EntitySchema` is
   * reported by an exception. This behaviour can be changed by this evolution mode however.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcEvolutionMode evolutionMode = 14;
   */
  evolutionMode: GrpcEvolutionMode[] = [];

  /**
   * Contains index of definitions of all sortable attribute compounds defined in this schema.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 15;
   */
  sortableAttributeCompounds: { [key: string]: GrpcSortableAttributeCompoundSchema } = {};

  /**
   * Contains entity type converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 16;
   */
  nameVariant: GrpcNameVariant[] = [];

  constructor(data?: PartialMessage<GrpcEntitySchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcEntitySchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "description", kind: "message", T: StringValue },
    { no: 4, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 5, name: "withGeneratedPrimaryKey", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "withHierarchy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "withPrice", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "indexedPricePlaces", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "locales", kind: "message", T: GrpcLocale, repeated: true },
    { no: 10, name: "currencies", kind: "message", T: GrpcCurrency, repeated: true },
    { no: 11, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcAttributeSchema} },
    { no: 12, name: "associatedData", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcAssociatedDataSchema} },
    { no: 13, name: "references", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcReferenceSchema} },
    { no: 14, name: "evolutionMode", kind: "enum", T: proto3.getEnumType(GrpcEvolutionMode), repeated: true },
    { no: 15, name: "sortableAttributeCompounds", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcSortableAttributeCompoundSchema} },
    { no: 16, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcEntitySchema {
    return new GrpcEntitySchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcEntitySchema {
    return new GrpcEntitySchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcEntitySchema {
    return new GrpcEntitySchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcEntitySchema | PlainMessage<GrpcEntitySchema> | undefined, b: GrpcEntitySchema | PlainMessage<GrpcEntitySchema> | undefined): boolean {
    return proto3.util.equals(GrpcEntitySchema, a, b);
  }
}

/**
 * This is the definition object for attributes that are stored along with
 * entity. Definition objects allow to describe the structure of the entity type so that
 * in any time everyone can consult complete structure of the entity type. Definition object is similar to Java reflection
 * process where you can also at any moment see which fields and methods are available for the class.
 *
 * Entity attributes allows defining set of data that are fetched in bulk along with the entity body.
 * Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
 * (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
 * memory space for data that will never be used in search queries.
 *
 * Filtering in attributes is executed by using constraints like `and`,
 * `not`, `attributeEquals`, `attributeContains`
 * and many others. Sorting can be achieved with `attributeNatural` or others.
 *
 * Attributes are not recommended for bigger data as they are all loaded at once requested.
 * Large data that are occasionally used store in `associatedData`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcAttributeSchema
 */
export class GrpcAttributeSchema extends Message<GrpcAttributeSchema> {
  /**
   * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * When this attribute schema belongs to a catalog - it is global and can have globally unique attributes enforced across whole catalog.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeSchemaType schemaType = 2;
   */
  schemaType = GrpcAttributeSchemaType.GLOBAL;

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 3;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this entity from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * If notice is `null`, this schema is considered not deprecated.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 4;
   */
  deprecationNotice?: string;

  /**
   * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
   * having certain value of this attribute among other entities in the same collection.
   *
   * As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
   * better to have this ensured by the database engine.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeUniquenessType unique = 5;
   */
  unique = GrpcAttributeUniquenessType.NOT_UNIQUE;

  /**
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcGlobalAttributeUniquenessType uniqueGlobally = 6;
   */
  uniqueGlobally = GrpcGlobalAttributeUniquenessType.NOT_GLOBALLY_UNIQUE;

  /**
   * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
   * as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
   * (memory/disk) space in the form of index.
   *
   * When attribute is filterable, extra result `attributeHistogram`
   * can be requested for this attribute.
   *
   * @generated from field: bool filterable = 7;
   */
  filterable = false;

  /**
   * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
   * as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
   * (memory/disk) space in the form of index.
   *
   * @generated from field: bool sortable = 8;
   */
  sortable = false;

  /**
   * When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
   *
   * @generated from field: bool localized = 9;
   */
  localized = false;

  /**
   * When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce
   * non-null checks upon upserting of the entity.
   *
   * @generated from field: bool nullable = 10;
   */
  nullable = false;

  /**
   * If an attribute is flagged as representative, it should be used in developer tools along with the entity's
   * primary key to describe the entity or reference to that entity. The flag is completely optional and doesn't
   * affect the core functionality of the database in any way. However, if it's used correctly, it can be very
   * helpful to developers in quickly finding their way around the data. There should be very few representative
   * attributes in the entity type, and the unique ones are usually the best to choose.
   *
   * @generated from field: bool representative = 11;
   */
  representative = false;

  /**
   * Data type of the attribute. Must be one of Evita-supported values.
   * Internally the scalar is converted into Java-corresponding data type.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcEvitaDataType type = 12;
   */
  type = GrpcEvitaDataType.STRING;

  /**
   * Default value is used when the entity is created without this attribute specified. Default values allow to pass
   * non-null checks even if no attributes of such name are specified.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcEvitaValue defaultValue = 13;
   */
  defaultValue?: GrpcEvitaValue;

  /**
   * Determines how many fractional places are important when entities are compared during filtering or sorting. It is
   * significant to know that all values of this attribute will be converted to `Int`, so the attribute
   * number must not ever exceed maximum limits of `Int` type when scaling the number by the power
   * of ten using `indexedDecimalPlaces` as exponent.
   *
   * @generated from field: int32 indexedDecimalPlaces = 14;
   */
  indexedDecimalPlaces = 0;

  /**
   * Contains attribute name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 15;
   */
  nameVariant: GrpcNameVariant[] = [];

  /**
   * Contains true if the attribute was inherited from the original object via reflected reference relation
   *
   * @generated from field: bool inherited = 16;
   */
  inherited = false;

  constructor(data?: PartialMessage<GrpcAttributeSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcAttributeSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schemaType", kind: "enum", T: proto3.getEnumType(GrpcAttributeSchemaType) },
    { no: 3, name: "description", kind: "message", T: StringValue },
    { no: 4, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 5, name: "unique", kind: "enum", T: proto3.getEnumType(GrpcAttributeUniquenessType) },
    { no: 6, name: "uniqueGlobally", kind: "enum", T: proto3.getEnumType(GrpcGlobalAttributeUniquenessType) },
    { no: 7, name: "filterable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "sortable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "localized", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "representative", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "type", kind: "enum", T: proto3.getEnumType(GrpcEvitaDataType) },
    { no: 13, name: "defaultValue", kind: "message", T: GrpcEvitaValue },
    { no: 14, name: "indexedDecimalPlaces", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 15, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 16, name: "inherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcAttributeSchema {
    return new GrpcAttributeSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcAttributeSchema {
    return new GrpcAttributeSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcAttributeSchema {
    return new GrpcAttributeSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcAttributeSchema | PlainMessage<GrpcAttributeSchema> | undefined, b: GrpcAttributeSchema | PlainMessage<GrpcAttributeSchema> | undefined): boolean {
    return proto3.util.equals(GrpcAttributeSchema, a, b);
  }
}

/**
 * This is the definition object for associated data that is stored along with
 * entity. Definition objects allow to describe the structure of the entity type so that
 * in any time everyone can consult complete structure of the entity type.
 *
 * Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
 * along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
 * in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
 * binary arrays representing entire files (i.e. pictures, documents).
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcAssociatedDataSchema
 */
export class GrpcAssociatedDataSchema extends Message<GrpcAssociatedDataSchema> {
  /**
   * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this entity from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * If notice is `null`, this schema is considered not deprecated.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * Data type of the associated data. Must be one of Evita-supported values.
   * Internally the type is converted into Java-corresponding data type.
   * The type may be scalar type or may represent complex object type (JSON).
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcEvitaAssociatedDataDataType.GrpcEvitaDataType type = 4;
   */
  type = GrpcEvitaAssociatedDataDataType_GrpcEvitaDataType.STRING;

  /**
   * Localized associated data has to be ALWAYS used in connection with specific `Locale`. In other
   * words - it cannot be stored unless associated locale is also provided.
   *
   * @generated from field: bool localized = 5;
   */
  localized = false;

  /**
   * When associated data is nullable, its values may be missing in the entities. Otherwise, the system will enforce
   * non-null checks upon upserting of the entity.
   *
   * @generated from field: bool nullable = 6;
   */
  nullable = false;

  /**
   * Contains associated data name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 7;
   */
  nameVariant: GrpcNameVariant[] = [];

  constructor(data?: PartialMessage<GrpcAssociatedDataSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcAssociatedDataSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(GrpcEvitaAssociatedDataDataType_GrpcEvitaDataType) },
    { no: 5, name: "localized", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcAssociatedDataSchema {
    return new GrpcAssociatedDataSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcAssociatedDataSchema {
    return new GrpcAssociatedDataSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcAssociatedDataSchema {
    return new GrpcAssociatedDataSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcAssociatedDataSchema | PlainMessage<GrpcAssociatedDataSchema> | undefined, b: GrpcAssociatedDataSchema | PlainMessage<GrpcAssociatedDataSchema> | undefined): boolean {
    return proto3.util.equals(GrpcAssociatedDataSchema, a, b);
  }
}

/**
 * This is the definition object for reference that is stored along with
 * entity. Definition objects allow to describe the structure of the entity type so that
 * in any time everyone can consult complete structure of the entity type.
 *
 * The references refer to other entities (of same or different entity type).
 * Allows entity filtering (but not sorting) of the entities by using `facet_{name}_inSet` query
 * and statistics computation if when requested. Reference
 * is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
 * part of multiple reference groups, that are also represented by int and entity type.
 *
 * Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
 * of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
 * to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
 * group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
 * Evita.
 *
 * References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcReferenceSchema
 */
export class GrpcReferenceSchema extends Message<GrpcReferenceSchema> {
  /**
   * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this entity from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * If notice is `null`, this schema is considered not deprecated.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
   * relationship from the perspective of the entity. We stick to the ERD modelling
   * [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
   * of the client API (returning only single reference or collections) and also help us to protect the consistency
   * of the data so that conforms to the creator mental model.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcCardinality cardinality = 4;
   */
  cardinality = GrpcCardinality.NOT_SPECIFIED;

  /**
   * Reference to `Entity.type` of the referenced entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: string entityType = 5;
   */
  entityType = "";

  /**
   * Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
   * DEPRECATED!!! use referencedEntityTypeManaged instead
   *
   * @generated from field: bool entityTypeRelatesToEntity = 6 [deprecated = true];
   * @deprecated
   */
  entityTypeRelatesToEntity = false;

  /**
   * Reference to `Entity.type` of the referenced entity. Might be also `String` that identifies type some external
   * resource not maintained by Evita.
   *
   * @generated from field: google.protobuf.StringValue groupType = 7;
   */
  groupType?: string;

  /**
   * Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
   * DEPRECATED!!! use referencedGroupTypeManaged instead
   *
   * @generated from field: bool groupTypeRelatesToEntity = 8 [deprecated = true];
   * @deprecated
   */
  groupTypeRelatesToEntity = false;

  /**
   * Contains `true` if the index for this reference should be created and maintained allowing to filter by
   * `reference_{reference name}_having` filtering constraints. Index is also required when reference is
   * `faceted`.
   *
   * Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference.
   * Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
   * the entity cannot be looked up by reference attributes or relation existence itself, but the data can be
   * fetched.
   *
   * @generated from field: bool indexed = 9;
   */
  indexed = false;

  /**
   * Contains `true` if the statistics data for this reference should be maintained and this allowing to get
   * `facetStatistics` for this reference or use `facet_{reference name}_inSet`
   * filtering constraint.
   *
   * Do not mark reference as faceted unless you want it among `facetStatistics`. Each faceted reference
   * occupies (memory/disk) space in the form of index.
   *
   * Reference that was marked as faceted is called Facet.
   *
   * @generated from field: bool faceted = 10;
   */
  faceted = false;

  /**
   * Attributes related to reference allows defining set of data that are fetched in bulk along with the entity body.
   * Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
   * (`AttributeSchema.filterable`). Attributes are not automatically indexed in order not to waste precious
   * memory space for data that will never be used in search queries.
   *
   * Filtering in attributes is executed by using constraints like `and`,
   * `not`, `attributeEquals`, `attributeContains`
   * and many others. Sorting can be achieved with `attributeNatural` or others.
   *
   * Attributes are not recommended for bigger data as they are all loaded at once.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcAttributeSchema> attributes = 11;
   */
  attributes: { [key: string]: GrpcAttributeSchema } = {};

  /**
   * Contains index of definitions of all sortable attribute compounds defined in this schema.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 12;
   */
  sortableAttributeCompounds: { [key: string]: GrpcSortableAttributeCompoundSchema } = {};

  /**
   * Contains reference name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 13;
   */
  nameVariant: GrpcNameVariant[] = [];

  /**
   * Contains referenced entity name converted to different naming conventions (only for non-managed entities).
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant entityTypeNameVariant = 14;
   */
  entityTypeNameVariant: GrpcNameVariant[] = [];

  /**
   * Contains referenced group name converted to different naming conventions (only for non-managed entities).
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant groupTypeNameVariant = 15;
   */
  groupTypeNameVariant: GrpcNameVariant[] = [];

  /**
   * Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
   *
   * @generated from field: bool referencedEntityTypeManaged = 16;
   */
  referencedEntityTypeManaged = false;

  /**
   * Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
   *
   * @generated from field: bool referencedGroupTypeManaged = 17;
   */
  referencedGroupTypeManaged = false;

  /**
   * Name of the reflected reference of the target referencedEntityType(). The referenced entity must contain reference
   * of such name and this reference must target the entity where the reflected reference is defined, and the target
   * entity must be managed on both sides of the relation.
   *
   * @generated from field: google.protobuf.StringValue reflectedReferenceName = 18;
   */
  reflectedReferenceName?: string;

  /**
   * Contains true if the description of the reflected reference is inherited from the target reference.
   *
   * @generated from field: bool descriptionInherited = 19;
   */
  descriptionInherited = false;

  /**
   * Contains true if the deprecated flag of the reflected reference is inherited from the target reference.
   *
   * @generated from field: bool deprecationNoticeInherited = 20;
   */
  deprecationNoticeInherited = false;

  /**
   * Contains true if the cardinality of the reflected reference is inherited from the target reference.
   *
   * @generated from field: bool cardinalityInherited = 21;
   */
  cardinalityInherited = false;

  /**
   * Contains true if the faceted property settings of the reflected reference is inherited from the target reference.
   *
   * @generated from field: bool facetedInherited = 22;
   */
  facetedInherited = false;

  /**
   * Contains true if the attributes of the reflected reference are inherited from the target reference.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeInheritanceBehavior attributeInheritanceBehavior = 23;
   */
  attributeInheritanceBehavior = GrpcAttributeInheritanceBehavior.INHERIT_ALL_EXCEPT;

  /**
   * The array of attribute names that are inherited / excluded from inheritance based on the value of
   * attributeInheritanceBehavior property.
   *
   * @generated from field: repeated string attributeInheritanceFilter = 24;
   */
  attributeInheritanceFilter: string[] = [];

  constructor(data?: PartialMessage<GrpcReferenceSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcReferenceSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "cardinality", kind: "enum", T: proto3.getEnumType(GrpcCardinality) },
    { no: 5, name: "entityType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "entityTypeRelatesToEntity", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "groupType", kind: "message", T: StringValue },
    { no: 8, name: "groupTypeRelatesToEntity", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "indexed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "faceted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcAttributeSchema} },
    { no: 12, name: "sortableAttributeCompounds", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcSortableAttributeCompoundSchema} },
    { no: 13, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 14, name: "entityTypeNameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 15, name: "groupTypeNameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 16, name: "referencedEntityTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "referencedGroupTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "reflectedReferenceName", kind: "message", T: StringValue },
    { no: 19, name: "descriptionInherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "deprecationNoticeInherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "cardinalityInherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "facetedInherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 23, name: "attributeInheritanceBehavior", kind: "enum", T: proto3.getEnumType(GrpcAttributeInheritanceBehavior) },
    { no: 24, name: "attributeInheritanceFilter", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcReferenceSchema {
    return new GrpcReferenceSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcReferenceSchema {
    return new GrpcReferenceSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcReferenceSchema {
    return new GrpcReferenceSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcReferenceSchema | PlainMessage<GrpcReferenceSchema> | undefined, b: GrpcReferenceSchema | PlainMessage<GrpcReferenceSchema> | undefined): boolean {
    return proto3.util.equals(GrpcReferenceSchema, a, b);
  }
}

/**
 * Sortable attribute compounds are used to sort entities or references by multiple attributes at once. evitaDB
 * requires a pre-sorted index in order to be able to sort entities or references by particular attribute or
 * combination of attributes, so it can deliver the results as fast as possible. Sortable attribute compounds
 * are filtered the same way as attributes - using natural ordering constraint.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcSortableAttributeCompoundSchema
 */
export class GrpcSortableAttributeCompoundSchema extends Message<GrpcSortableAttributeCompoundSchema> {
  /**
   * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this entity from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * If notice is `null`, this schema is considered not deprecated.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * Collection of attribute elements that define the sortable compound. The order of the elements
   * is important, as it defines the order of the sorting.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcAttributeElement attributeElements = 4;
   */
  attributeElements: GrpcAttributeElement[] = [];

  /**
   * Contains attribute compound name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 5;
   */
  nameVariant: GrpcNameVariant[] = [];

  /**
   * Contains true if the attribute was inherited from the original object via reflected reference relation
   *
   * @generated from field: bool inherited = 6;
   */
  inherited = false;

  constructor(data?: PartialMessage<GrpcSortableAttributeCompoundSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcSortableAttributeCompoundSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "attributeElements", kind: "message", T: GrpcAttributeElement, repeated: true },
    { no: 5, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 6, name: "inherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcSortableAttributeCompoundSchema {
    return new GrpcSortableAttributeCompoundSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcSortableAttributeCompoundSchema {
    return new GrpcSortableAttributeCompoundSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcSortableAttributeCompoundSchema {
    return new GrpcSortableAttributeCompoundSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcSortableAttributeCompoundSchema | PlainMessage<GrpcSortableAttributeCompoundSchema> | undefined, b: GrpcSortableAttributeCompoundSchema | PlainMessage<GrpcSortableAttributeCompoundSchema> | undefined): boolean {
    return proto3.util.equals(GrpcSortableAttributeCompoundSchema, a, b);
  }
}

/**
 * Attribute element is a part of the sortable compound. It defines the attribute name, the direction of the
 * sorting and the behaviour of the null values. The attribute name refers to the existing attribute defined in the
 * schema.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcAttributeElement
 */
export class GrpcAttributeElement extends Message<GrpcAttributeElement> {
  /**
   * Name of the existing attribute in the same schema.
   *
   * @generated from field: string attributeName = 1;
   */
  attributeName = "";

  /**
   * Direction of the sorting.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcOrderDirection direction = 2;
   */
  direction = GrpcOrderDirection.ASC;

  /**
   * Behaviour of the null values.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcOrderBehaviour behaviour = 3;
   */
  behaviour = GrpcOrderBehaviour.NULLS_FIRST;

  constructor(data?: PartialMessage<GrpcAttributeElement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcAttributeElement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attributeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "direction", kind: "enum", T: proto3.getEnumType(GrpcOrderDirection) },
    { no: 3, name: "behaviour", kind: "enum", T: proto3.getEnumType(GrpcOrderBehaviour) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcAttributeElement {
    return new GrpcAttributeElement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcAttributeElement {
    return new GrpcAttributeElement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcAttributeElement {
    return new GrpcAttributeElement().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcAttributeElement | PlainMessage<GrpcAttributeElement> | undefined, b: GrpcAttributeElement | PlainMessage<GrpcAttributeElement> | undefined): boolean {
    return proto3.util.equals(GrpcAttributeElement, a, b);
  }
}

