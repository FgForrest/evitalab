// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file GrpcReferenceSchemaMutations.proto (package io.evitadb.externalApi.grpc.generated, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BoolValue, Message, proto3, StringValue } from "@bufbuild/protobuf";
import { GrpcAttributeInheritanceBehavior, GrpcCardinality } from "./GrpcEnums_pb.js";
import { GrpcAttributeSchemaMutation } from "./GrpcAttributeSchemaMutations_pb.js";
import { GrpcSortableAttributeCompoundSchemaMutation } from "./GrpcSortableAttributeCompoundSchemaMutations_pb.js";

/**
 * Mutation is responsible for setting up a new `ReferenceSchema` in the `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcCreateReferenceSchemaMutation
 */
export class GrpcCreateReferenceSchemaMutation extends Message<GrpcCreateReferenceSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this schema from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
   * relationship from the perspective of the entity. We stick to the ERD modelling
   * [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
   * of the client API (returning only single reference or collections) and also help us to protect the consistency
   * of the data so that conforms to the creator mental model.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcCardinality cardinality = 4;
   */
  cardinality = GrpcCardinality.NOT_SPECIFIED;

  /**
   * Reference to `EntitySchema.name` of the referenced entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: string referencedEntityType = 5;
   */
  referencedEntityType = "";

  /**
   * Whether `referencedEntityType` refers to any existing `EntitySchema.name` that is
   * maintained by Evita.
   *
   * @generated from field: bool referencedEntityTypeManaged = 6;
   */
  referencedEntityTypeManaged = false;

  /**
   * Reference to `EntitySchema.name` of the referenced group entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: google.protobuf.StringValue referencedGroupType = 7;
   */
  referencedGroupType?: string;

  /**
   * Whether `referencedGroupType` refers to any existing `EntitySchema.name` that is
   * maintained by Evita.
   *
   * @generated from field: bool referencedGroupTypeManaged = 8;
   */
  referencedGroupTypeManaged = false;

  /**
   * Whether the index for this reference should be created and maintained allowing to filter by
   * `referenceHaving` filtering constraints. Index is also required when reference is
   * `faceted`.
   *
   * Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference.
   * Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
   * the entity cannot be looked up by reference attributes or relation existence itself, but the data is loaded
   * alongside other references if requested.
   *
   * @generated from field: bool filterable = 9;
   */
  filterable = false;

  /**
   * Whether the statistics data for this reference should be maintained and this allowing to get
   * `facetSummary` for this reference or use `facetInSet`
   * filtering query.
   *
   * Do not mark reference as faceted unless you want it among `FacetStatistics`. Each faceted reference
   * occupies (memory/disk) space in the form of index.
   * Reference that was marked as faceted is called Facet.
   *
   * @generated from field: bool faceted = 10;
   */
  faceted = false;

  constructor(data?: PartialMessage<GrpcCreateReferenceSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcCreateReferenceSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "cardinality", kind: "enum", T: proto3.getEnumType(GrpcCardinality) },
    { no: 5, name: "referencedEntityType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "referencedEntityTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "referencedGroupType", kind: "message", T: StringValue },
    { no: 8, name: "referencedGroupTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "filterable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "faceted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcCreateReferenceSchemaMutation {
    return new GrpcCreateReferenceSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcCreateReferenceSchemaMutation {
    return new GrpcCreateReferenceSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcCreateReferenceSchemaMutation {
    return new GrpcCreateReferenceSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcCreateReferenceSchemaMutation | PlainMessage<GrpcCreateReferenceSchemaMutation> | undefined, b: GrpcCreateReferenceSchemaMutation | PlainMessage<GrpcCreateReferenceSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcCreateReferenceSchemaMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting up a new `ReflectedReferenceSchema` in the `EntitySchema`.
 * Mutation can be used for altering also the existing `ReflectedReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcCreateReflectedReferenceSchemaMutation
 */
export class GrpcCreateReflectedReferenceSchemaMutation extends Message<GrpcCreateReflectedReferenceSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * Deprecation notice contains information about planned removal of this schema from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
   * relationship from the perspective of the entity. We stick to the ERD modelling
   * [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
   * of the client API (returning only single reference or collections) and also help us to protect the consistency
   * of the data so that conforms to the creator mental model.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcCardinality cardinality = 4;
   */
  cardinality = GrpcCardinality.NOT_SPECIFIED;

  /**
   * Reference to `EntitySchema.name` of the referenced entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: string referencedEntityType = 5;
   */
  referencedEntityType = "";

  /**
   * Name of the reflected reference of the target referencedEntityType(). The referenced entity must contain reference
   * of such name and this reference must target the entity where the reflected reference is defined, and the target
   * entity must be managed on both sides of the relation.
   *
   * @generated from field: string reflectedReferenceName = 6;
   */
  reflectedReferenceName = "";

  /**
   * Whether the statistics data for this reference should be maintained and this allowing to get
   * `facetSummary` for this reference or use `facetInSet`
   * filtering query.
   *
   * Do not mark reference as faceted unless you want it among `FacetStatistics`. Each faceted reference
   * occupies (memory/disk) space in the form of index.
   * Reference that was marked as faceted is called Facet.
   *
   * @generated from field: google.protobuf.BoolValue faceted = 7;
   */
  faceted?: boolean;

  /**
   * Contains true if the attributes of the reflected reference are inherited from the target reference.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeInheritanceBehavior attributeInheritanceBehavior = 8;
   */
  attributeInheritanceBehavior = GrpcAttributeInheritanceBehavior.INHERIT_ALL_EXCEPT;

  /**
   * The array of attribute names that are inherited / excluded from inheritance based on the value of
   * attributeInheritanceBehavior property.
   *
   * @generated from field: repeated string attributeInheritanceFilter = 9;
   */
  attributeInheritanceFilter: string[] = [];

  constructor(data?: PartialMessage<GrpcCreateReflectedReferenceSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcCreateReflectedReferenceSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "cardinality", kind: "enum", T: proto3.getEnumType(GrpcCardinality) },
    { no: 5, name: "referencedEntityType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "reflectedReferenceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "faceted", kind: "message", T: BoolValue },
    { no: 8, name: "attributeInheritanceBehavior", kind: "enum", T: proto3.getEnumType(GrpcAttributeInheritanceBehavior) },
    { no: 9, name: "attributeInheritanceFilter", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcCreateReflectedReferenceSchemaMutation {
    return new GrpcCreateReflectedReferenceSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcCreateReflectedReferenceSchemaMutation {
    return new GrpcCreateReflectedReferenceSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcCreateReflectedReferenceSchemaMutation {
    return new GrpcCreateReflectedReferenceSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcCreateReflectedReferenceSchemaMutation | PlainMessage<GrpcCreateReflectedReferenceSchemaMutation> | undefined, b: GrpcCreateReflectedReferenceSchemaMutation | PlainMessage<GrpcCreateReflectedReferenceSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcCreateReflectedReferenceSchemaMutation, a, b);
  }
}

/**
 * Mutation is a holder for a single `AttributeSchema` that affect any of `ReferenceSchema.attributes` in the `EntitySchema`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceAttributeSchemaMutation
 */
export class GrpcModifyReferenceAttributeSchemaMutation extends Message<GrpcModifyReferenceAttributeSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Nested attribute schema mutation that mutates reference attributes of targeted reference.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeSchemaMutation attributeSchemaMutation = 2;
   */
  attributeSchemaMutation?: GrpcAttributeSchemaMutation;

  constructor(data?: PartialMessage<GrpcModifyReferenceAttributeSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceAttributeSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attributeSchemaMutation", kind: "message", T: GrpcAttributeSchemaMutation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceAttributeSchemaMutation {
    return new GrpcModifyReferenceAttributeSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceAttributeSchemaMutation {
    return new GrpcModifyReferenceAttributeSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceAttributeSchemaMutation {
    return new GrpcModifyReferenceAttributeSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceAttributeSchemaMutation | PlainMessage<GrpcModifyReferenceAttributeSchemaMutation> | undefined, b: GrpcModifyReferenceAttributeSchemaMutation | PlainMessage<GrpcModifyReferenceAttributeSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceAttributeSchemaMutation, a, b);
  }
}

/**
 * Mutation is a holder for a single `SortableAttributeCompoundSchema` that affect any of
 * `ReferenceSchema.sortableAttributeCompound` in the `EntitySchema`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSortableAttributeCompoundSchemaMutation
 */
export class GrpcModifyReferenceSortableAttributeCompoundSchemaMutation extends Message<GrpcModifyReferenceSortableAttributeCompoundSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Nested sortable attribute compound schema mutation that mutates reference sortable attribute compounds of targeted reference.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcSortableAttributeCompoundSchemaMutation sortableAttributeCompoundSchemaMutation = 2;
   */
  sortableAttributeCompoundSchemaMutation?: GrpcSortableAttributeCompoundSchemaMutation;

  constructor(data?: PartialMessage<GrpcModifyReferenceSortableAttributeCompoundSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSortableAttributeCompoundSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sortableAttributeCompoundSchemaMutation", kind: "message", T: GrpcSortableAttributeCompoundSchemaMutation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSortableAttributeCompoundSchemaMutation {
    return new GrpcModifyReferenceSortableAttributeCompoundSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSortableAttributeCompoundSchemaMutation {
    return new GrpcModifyReferenceSortableAttributeCompoundSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSortableAttributeCompoundSchemaMutation {
    return new GrpcModifyReferenceSortableAttributeCompoundSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSortableAttributeCompoundSchemaMutation | PlainMessage<GrpcModifyReferenceSortableAttributeCompoundSchemaMutation> | undefined, b: GrpcModifyReferenceSortableAttributeCompoundSchemaMutation | PlainMessage<GrpcModifyReferenceSortableAttributeCompoundSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSortableAttributeCompoundSchemaMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.cardinality` in `EntitySchema`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaCardinalityMutation
 */
export class GrpcModifyReferenceSchemaCardinalityMutation extends Message<GrpcModifyReferenceSchemaCardinalityMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
   * relationship from the perspective of the entity. We stick to the ERD modelling
   * [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
   * of the client API (returning only single reference or collections) and also help us to protect the consistency
   * of the data so that conforms to the creator mental model.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcCardinality cardinality = 2;
   */
  cardinality = GrpcCardinality.NOT_SPECIFIED;

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaCardinalityMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaCardinalityMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cardinality", kind: "enum", T: proto3.getEnumType(GrpcCardinality) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaCardinalityMutation {
    return new GrpcModifyReferenceSchemaCardinalityMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaCardinalityMutation {
    return new GrpcModifyReferenceSchemaCardinalityMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaCardinalityMutation {
    return new GrpcModifyReferenceSchemaCardinalityMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaCardinalityMutation | PlainMessage<GrpcModifyReferenceSchemaCardinalityMutation> | undefined, b: GrpcModifyReferenceSchemaCardinalityMutation | PlainMessage<GrpcModifyReferenceSchemaCardinalityMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaCardinalityMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.deprecationNotice` in `EntitySchema`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaDeprecationNoticeMutation
 */
export class GrpcModifyReferenceSchemaDeprecationNoticeMutation extends Message<GrpcModifyReferenceSchemaDeprecationNoticeMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Deprecation notice contains information about planned removal of this schema from the model / client API.
   * This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 2;
   */
  deprecationNotice?: string;

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaDeprecationNoticeMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaDeprecationNoticeMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deprecationNotice", kind: "message", T: StringValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaDeprecationNoticeMutation {
    return new GrpcModifyReferenceSchemaDeprecationNoticeMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaDeprecationNoticeMutation {
    return new GrpcModifyReferenceSchemaDeprecationNoticeMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaDeprecationNoticeMutation {
    return new GrpcModifyReferenceSchemaDeprecationNoticeMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaDeprecationNoticeMutation | PlainMessage<GrpcModifyReferenceSchemaDeprecationNoticeMutation> | undefined, b: GrpcModifyReferenceSchemaDeprecationNoticeMutation | PlainMessage<GrpcModifyReferenceSchemaDeprecationNoticeMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaDeprecationNoticeMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.description` in `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaDescriptionMutation
 */
export class GrpcModifyReferenceSchemaDescriptionMutation extends Message<GrpcModifyReferenceSchemaDescriptionMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaDescriptionMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaDescriptionMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaDescriptionMutation {
    return new GrpcModifyReferenceSchemaDescriptionMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaDescriptionMutation {
    return new GrpcModifyReferenceSchemaDescriptionMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaDescriptionMutation {
    return new GrpcModifyReferenceSchemaDescriptionMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaDescriptionMutation | PlainMessage<GrpcModifyReferenceSchemaDescriptionMutation> | undefined, b: GrpcModifyReferenceSchemaDescriptionMutation | PlainMessage<GrpcModifyReferenceSchemaDescriptionMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaDescriptionMutation, a, b);
  }
}

/**
 * Mutation is responsible for renaming an existing `ReferenceSchema` in `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaNameMutation
 */
export class GrpcModifyReferenceSchemaNameMutation extends Message<GrpcModifyReferenceSchemaNameMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * New name of the reference the mutation is targeting.
   *
   * @generated from field: string newName = 2;
   */
  newName = "";

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaNameMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaNameMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "newName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaNameMutation {
    return new GrpcModifyReferenceSchemaNameMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaNameMutation {
    return new GrpcModifyReferenceSchemaNameMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaNameMutation {
    return new GrpcModifyReferenceSchemaNameMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaNameMutation | PlainMessage<GrpcModifyReferenceSchemaNameMutation> | undefined, b: GrpcModifyReferenceSchemaNameMutation | PlainMessage<GrpcModifyReferenceSchemaNameMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaNameMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.referencedGroupType`in `EntitySchema`.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaRelatedEntityGroupMutation
 */
export class GrpcModifyReferenceSchemaRelatedEntityGroupMutation extends Message<GrpcModifyReferenceSchemaRelatedEntityGroupMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Reference to `EntitySchema.name` of the referenced group entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: google.protobuf.StringValue referencedGroupType = 2;
   */
  referencedGroupType?: string;

  /**
   * Whether `referencedGroupType` refers to any existing `EntitySchema.name` that is maintained by Evita.
   *
   * @generated from field: bool referencedGroupTypeManaged = 3;
   */
  referencedGroupTypeManaged = false;

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaRelatedEntityGroupMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaRelatedEntityGroupMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "referencedGroupType", kind: "message", T: StringValue },
    { no: 3, name: "referencedGroupTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaRelatedEntityGroupMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityGroupMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaRelatedEntityGroupMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityGroupMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaRelatedEntityGroupMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityGroupMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaRelatedEntityGroupMutation | PlainMessage<GrpcModifyReferenceSchemaRelatedEntityGroupMutation> | undefined, b: GrpcModifyReferenceSchemaRelatedEntityGroupMutation | PlainMessage<GrpcModifyReferenceSchemaRelatedEntityGroupMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaRelatedEntityGroupMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.referencedEntityType` in `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaRelatedEntityMutation
 */
export class GrpcModifyReferenceSchemaRelatedEntityMutation extends Message<GrpcModifyReferenceSchemaRelatedEntityMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Reference to `EntitySchema.name` of the referenced entity. Might be also any `String`
   * that identifies type some external resource not maintained by Evita.
   *
   * @generated from field: string referencedEntityType = 2;
   */
  referencedEntityType = "";

  /**
   * Whether `referencedEntityType` refers to any existing `EntitySchema.name` that is maintained by Evita.
   *
   * @generated from field: bool referencedEntityTypeManaged = 3;
   */
  referencedEntityTypeManaged = false;

  constructor(data?: PartialMessage<GrpcModifyReferenceSchemaRelatedEntityMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReferenceSchemaRelatedEntityMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "referencedEntityType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "referencedEntityTypeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReferenceSchemaRelatedEntityMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaRelatedEntityMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReferenceSchemaRelatedEntityMutation {
    return new GrpcModifyReferenceSchemaRelatedEntityMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReferenceSchemaRelatedEntityMutation | PlainMessage<GrpcModifyReferenceSchemaRelatedEntityMutation> | undefined, b: GrpcModifyReferenceSchemaRelatedEntityMutation | PlainMessage<GrpcModifyReferenceSchemaRelatedEntityMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReferenceSchemaRelatedEntityMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReflectedReferenceSchema.attributesInherited` and
 * `ReflectedReferenceSchema.attributesExcludedFromInheritance` in `ReferenceSchema`.
 * Mutation can be used for altering also the existing `ReferenceSchemaContract` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation
 */
export class GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation extends Message<GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains true if the attributes of the reflected reference are inherited from the target reference.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeInheritanceBehavior attributeInheritanceBehavior = 2;
   */
  attributeInheritanceBehavior = GrpcAttributeInheritanceBehavior.INHERIT_ALL_EXCEPT;

  /**
   * The array of attribute names that are inherited / excluded from inheritance based on the value of
   * attributeInheritanceBehavior property.
   *
   * @generated from field: repeated string attributeInheritanceFilter = 3;
   */
  attributeInheritanceFilter: string[] = [];

  constructor(data?: PartialMessage<GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attributeInheritanceBehavior", kind: "enum", T: proto3.getEnumType(GrpcAttributeInheritanceBehavior) },
    { no: 3, name: "attributeInheritanceFilter", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation {
    return new GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation {
    return new GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation {
    return new GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation | PlainMessage<GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation> | undefined, b: GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation | PlainMessage<GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcModifyReflectedReferenceAttributeInheritanceSchemaMutation, a, b);
  }
}

/**
 * Mutation is responsible for removing an existing `ReferenceSchema` in the `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcRemoveReferenceSchemaMutation
 */
export class GrpcRemoveReferenceSchemaMutation extends Message<GrpcRemoveReferenceSchemaMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GrpcRemoveReferenceSchemaMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcRemoveReferenceSchemaMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcRemoveReferenceSchemaMutation {
    return new GrpcRemoveReferenceSchemaMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcRemoveReferenceSchemaMutation {
    return new GrpcRemoveReferenceSchemaMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcRemoveReferenceSchemaMutation {
    return new GrpcRemoveReferenceSchemaMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcRemoveReferenceSchemaMutation | PlainMessage<GrpcRemoveReferenceSchemaMutation> | undefined, b: GrpcRemoveReferenceSchemaMutation | PlainMessage<GrpcRemoveReferenceSchemaMutation> | undefined): boolean {
    return proto3.util.equals(GrpcRemoveReferenceSchemaMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.faceted in `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcSetReferenceSchemaFacetedMutation
 */
export class GrpcSetReferenceSchemaFacetedMutation extends Message<GrpcSetReferenceSchemaFacetedMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Whether the statistics data for this reference should be maintained and this allowing to get
   * `facetSummary` for this reference or use `facet_{reference name}_inSet`
   * filtering query.
   *
   * Do not mark reference as faceted unless you want it among `FacetStatistics`. Each faceted reference
   * occupies (memory/disk) space in the form of index.
   * Reference that was marked as faceted is called Facet.
   *
   * @generated from field: bool faceted = 2;
   */
  faceted = false;

  /**
   * Set to true when the faceted property should be inherited from the original.
   * This property makes sense only for inherited reference attributes on reflected reference. For all other cases it
   * must be left as false. When set to TRUE the value of `faceted` field is ignored.
   *
   * @generated from field: bool inherited = 3;
   */
  inherited = false;

  constructor(data?: PartialMessage<GrpcSetReferenceSchemaFacetedMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcSetReferenceSchemaFacetedMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "faceted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "inherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcSetReferenceSchemaFacetedMutation {
    return new GrpcSetReferenceSchemaFacetedMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcSetReferenceSchemaFacetedMutation {
    return new GrpcSetReferenceSchemaFacetedMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcSetReferenceSchemaFacetedMutation {
    return new GrpcSetReferenceSchemaFacetedMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcSetReferenceSchemaFacetedMutation | PlainMessage<GrpcSetReferenceSchemaFacetedMutation> | undefined, b: GrpcSetReferenceSchemaFacetedMutation | PlainMessage<GrpcSetReferenceSchemaFacetedMutation> | undefined): boolean {
    return proto3.util.equals(GrpcSetReferenceSchemaFacetedMutation, a, b);
  }
}

/**
 * Mutation is responsible for setting value to a `ReferenceSchema.filtered` in `EntitySchema`.
 * Mutation can be used for altering also the existing `ReferenceSchema` alone.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcSetReferenceSchemaFilterableMutation
 */
export class GrpcSetReferenceSchemaFilterableMutation extends Message<GrpcSetReferenceSchemaFilterableMutation> {
  /**
   * Name of the reference the mutation is targeting.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Whether the index for this reference should be created and maintained allowing to filter by
   * `referenceHaving` filtering constraints. Index is also required when reference is `faceted`.
   *
   * Do not mark reference as faceted unless you know that you'll need to filter / sort entities by this reference.
   * Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
   * the entity cannot be looked up by reference attributes or relation existence itself, but the data is loaded
   * alongside other references if requested.
   *
   * @generated from field: bool filterable = 2;
   */
  filterable = false;

  /**
   * Set to true when the filterable property should be inherited from the original.
   * This property makes sense only for inherited reference attributes on reflected reference. For all other cases it
   * must be left as false. When set to TRUE the value of `filterable` field is ignored.
   *
   * @generated from field: bool inherited = 3;
   */
  inherited = false;

  constructor(data?: PartialMessage<GrpcSetReferenceSchemaFilterableMutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcSetReferenceSchemaFilterableMutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filterable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "inherited", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcSetReferenceSchemaFilterableMutation {
    return new GrpcSetReferenceSchemaFilterableMutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcSetReferenceSchemaFilterableMutation {
    return new GrpcSetReferenceSchemaFilterableMutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcSetReferenceSchemaFilterableMutation {
    return new GrpcSetReferenceSchemaFilterableMutation().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcSetReferenceSchemaFilterableMutation | PlainMessage<GrpcSetReferenceSchemaFilterableMutation> | undefined, b: GrpcSetReferenceSchemaFilterableMutation | PlainMessage<GrpcSetReferenceSchemaFilterableMutation> | undefined): boolean {
    return proto3.util.equals(GrpcSetReferenceSchemaFilterableMutation, a, b);
  }
}

