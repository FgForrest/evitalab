/*
    evitaDB model (more precisely, simplified model used in lab API).
    Initially generated by Swagger codegen, but modified because of generated inaccuracies.
 */

/**
 * Represents a precise float number from evitaDB represented as string.
 */
export type BigDecimal = string;
/**
 * Represents 64-bit integer from evitaDB represented as string.
 */
export type Long = string;
/**
 * Represents ISO date time as string
 */
export type DateTime = string;

/**
 * List of support scalars supported by evitaDB.
 */
export enum Scalar {
    String = 'String',
    StringArray = 'StringArray',
    Byte = 'Byte',
    ByteArray = 'ByteArray',
    Short = 'Short',
    ShortArray = 'ShortArray',
    Integer = 'Integer',
    IntegerArray = 'IntegerArray',
    Long = 'Long',
    LongArray = 'LongArray',
    Boolean = 'Boolean',
    BooleanArray = 'BooleanArray',
    Character = 'Character',
    CharacterArray = 'CharacterArray',
    BigDecimal = 'BigDecimal',
    BigDecimalArray = 'BigDecimalArray',
    OffsetDateTime = 'OffsetDateTime',
    OffsetDateTimeArray = 'OffsetDateTimeArray',
    LocalDateTime = 'LocalDateTime',
    LocalDateTimeArray = 'LocalDateTimeArray',
    LocalDate = 'LocalDate',
    LocalDateArray = 'LocalDateArray',
    LocalTime = 'LocalTime',
    LocalTimeArray = 'LocalTimeArray',
    DateTimeRange = 'DateTimeRange',
    DateTimeRangeArray = 'DateTimeRangeArray',
    BigDecimalNumberRange = 'BigDecimalNumberRange',
    BigDecimalNumberRangeArray = 'BigDecimalNumberRangeArray',
    ByteNumberRange = 'ByteNumberRange',
    ByteNumberRangeArray = 'ByteNumberRangeArray',
    ShortNumberRange = 'ShortNumberRange',
    ShortNumberRangeArray = 'ShortNumberRangeArray',
    IntegerNumberRange = 'IntegerNumberRange',
    IntegerNumberRangeArray = 'IntegerNumberRangeArray',
    LongNumberRange = 'LongNumberRange',
    LongNumberRangeArray = 'LongNumberRangeArray',
    Locale = 'Locale',
    LocaleArray = 'LocaleArray',
    Currency = 'Currency',
    CurrencyArray = 'CurrencyArray',
    UUID = 'UUID',
    UUIDArray = 'UUIDArray',
    Predecessor = 'Predecessor',
    ComplexDataObject = 'ComplexDataObject'
}

/**
 * This is the definition object for associated data that is stored along with entity. Definition objects allow to describe the structure of the entity type so that in any time everyone can consult complete structure of the entity type.  Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large binary arrays representing entire files (i.e. pictures, documents).
 */
export interface AssociatedDataSchema {
    /**
     * When associated data is nullable, its values may be missing in the entities. Otherwise, the system will enforce non-null checks upon upserting of the entity.
     */
    nullable: boolean;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Localized associated data has to be ALWAYS used in connection with specific `Locale`. In other words - it cannot be stored unless associated locale is also provided.
     */
    localized: boolean;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * Data type of the associated data. Must be one of Evita-supported values. Internally the type is converted into Java-corresponding data type. The type may be scalar type or may represent complex object type (JSON).
     */
    type: string;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     * Contains name variants
     */
    nameVariants: NameVariants;
}
/**
 * Contains all associated data schemas relevant for parent schema.
 */
export interface AssociatedDataSchemas extends Record<string, AssociatedDataSchema> {
    [key: string]: AssociatedDataSchema;

}
/**
 * Contains all attribute schemas relevant for parent schema.
 */
export interface AttributeSchemas extends Record<string, AttributeSchemaUnion> {
    [key: string]: AttributeSchemaUnion;

}
/**
 * Attribute element is a part of the sortable compound. It defines the attribute name, the direction of the sorting and the behaviour of the null values. The attribute name refers to the existing attribute defined in the schema.
 */
export interface AttributeElement {
    /**
     * Name of the existing attribute in the same schema.
     */
    attributeName: string;
    behaviour: OrderBehaviour;
    direction: OrderDirection;
}
/**
 * Attribute histogram is just index for `Histogram` objects for multiple attributes.
 */
export interface AttributeHistogram extends Record<string, Histogram> {
    [key: string]: Histogram;

}
/**
 * This is the definition object for attributes that are stored along with entity. Definition objects allow to describe the structure of the entity type so that in any time everyone can consult complete structure of the entity type. Definition object is similar to Java reflection process where you can also at any moment see which fields and methods are available for the class.  Entity attributes allows defining set of data that are fetched in bulk along with the entity body. Attributes may be indexed for fast filtering or can be used to sort along. Attributes are not automatically indexed in order not to waste precious memory space for data that will never be used in search queries.  Filtering in attributes is executed by using constraints like `and`, `or`, `not`, `attribute_{name}_equals`, `attribute_{name}_contains` and many others. Sorting can be achieved with `attribute_{name}_natural` or others.  Attributes are not recommended for bigger data as they are all loaded at once when requested. Large data that are occasionally used store in associated data.
 */
export interface AttributeSchema {
    /**
     * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies (memory/disk) space in the form of index.  When attribute is filterable, extra result `attributeHistogram` can be requested for this attribute.
     */
    filterable: boolean;
    /**
     * When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce non-null checks upon upserting of the entity.
     */
    nullable: boolean;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Default value is used when the entity is created without this attribute specified. Default values allow to pass non-null checks even if no attributes of such name are specified.
     */
    defaultValue?: string | number | boolean | Array<any> | any;
    /**
     * When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
     */
    localized: boolean;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies (memory/disk) space in the form of index..
     */
    sortable: boolean;
    /**
     * Data type of the attribute. Must be one of Evita-supported values. Internally the scalar is converted into Java-corresponding data type.
     */
    type: string;
    /**
     * Determines how many fractional places are important when entities are compared during filtering or sorting. It is significant to know that all values of this attribute will be converted to `Int`, so the attribute number must not ever exceed maximum limits of `Int` type when scaling the number by the power of ten using `indexedDecimalPlaces` as exponent.
     */
    indexedDecimalPlaces: number;
    /**
     * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity having certain value of this attribute among other entities in the same collection.  As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's better to have this ensured by the database engine.
     */
    uniquenessType: AttributeUniquenessType;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
}
/**
 * Returns either `attributeSchema` or `globalAttributeSchema`.
 */
export type AttributeSchemaUnion = AttributeSchema | EntityAttributeSchema | GlobalAttributeSchema;

export enum AttributeUniquenessType {

    /**
     * The attribute is not unique (default).
     */
    NotUnique = 'NOT_UNIQUE',
    /**
     * The attribute value must be unique among all the entities of the same collection.
     */
    UniqueWithinCollection = 'UNIQUE_WITHIN_COLLECTION',
    /**
     * The localized attribute value must be unique among all values of the same locale among all the entities
     * using of the same collection.
     */
    UniqueWithinCollectionLocale = 'UNIQUE_WITHIN_COLLECTION_LOCALE'
}

export enum GlobalAttributeUniquenessType {

    /**
     * The attribute is not unique (default).
     */
    NotUnique = 'NOT_UNIQUE',
    /**
     * The attribute value (either localized or non-localized) must be unique among all values among all the entities
     * using this {@link GlobalAttributeSchema} in the entire catalog.
     */
    UniqueWithinCatalog = 'UNIQUE_WITHIN_CATALOG',
    /**
     * The localized attribute value must be unique among all values of the same locale among all the entities
     * using this {@link GlobalAttributeSchema} in the entire catalog.
     */
    UniqueWithinCatalogLocale = 'UNIQUE_WITHIN_CATALOG_LOCALE'

}

export enum Cardinality {
    ZeroOrOne = 'ZERO_OR_ONE',
    ExactlyOne = 'EXACTLY_ONE',
    ZeroOrMore = 'ZERO_OR_MORE',
    OneOrMore = 'ONE_OR_MORE'
}
/**
 * Catalog is a fragment of evitaDB database that can be compared to a schema of relational database. Catalog allows handling multiple isolated data collections inside single evitaDB instance. Catalogs in evitaDB are isolated one from another and share no single thing.  Catalog is an abstraction for \"database\" in the sense of relational databases. Catalog contains all entities and data connected with single client. In the e-commerce world catalog means \"single e-shop\" although it may not be the truth in every case. Catalog manages set of entity collection uniquely identified by their name.
 */
export interface Catalog {
    /**
     * Whether this catalog is corrupted or can be freely used.
     */
    corrupted: boolean;
    /**
     * Returns true if catalog supports transaction.
     */
    supportsTransaction: boolean;
    /**
     * Catalog header version that is incremented with each update. Version is not stored on the disk, it serves only to distinguish whether there is any change made in the header and whether it needs to be persisted on disk.
     */
    version: string;
    /**
     *
     */
    catalogState: CatalogState;
    /**
     * Name of the catalog. Name must be unique across all catalogs inside same evitaDB instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
    /**
     * Set of all maintained entity collections - i.e. entity types.
     */
    entityTypes: Array<string>;
}
/**
 * Internal Evita's catalog schema containing structural information about one Evita catalog.
 */
export interface CatalogSchema {
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * Contains version of this definition object and gets increased with any entity type update. Allows to execute optimistic locking i.e. avoiding parallel modifications.
     */
    version: number;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
    /**
     *
     */
    attributes: GlobalAttributeSchemas;
    /**
     *
     */
    entitySchemas: EntitySchemas;
}

export enum CatalogState {
    WarmingUp = 'WARMING_UP',
    Alive = 'ALIVE'
}
/**
 * Contains all possible catalog instance implementations.
 */
export interface CatalogUnion {
}
/**
 * Catalog instance that cannot be loaded into a memory due an error. The original exception and catalog path are accessible via. `catalogStoragePath` and `cause` properties.
 */
export interface CorruptedCatalog {
    /**
     * Whether this catalog is corrupted or can be freely used.
     */
    corrupted: boolean;
    /**
     * Cause of catalog corruption.
     */
    cause: string;
    /**
     * Path to original catalog.
     */
    catalogStoragePath: string;
    /**
     * Name of the catalog. Name must be unique across all catalogs inside same evitaDB instance.
     */
    name: string;
}
/**
 * Returns either `page` or `strip` of records according to pagination rules in input query.
 */
export interface DataChunk {
    /**
     *
     */
    type: string;
    /**
     * Actual found sorted page/strip of records.
     */
    data: Array<Entity>;
    /**
     * Returns total number of records that are possible to fetch by paginating entire result stream.
     */
    totalRecordCount: number;
    /**
     * Returns true if current page/strip is the first page/strip in the result set.
     */
    first: boolean;
    /**
     * Returns true if current page/strip is the last page/strip in the result set.
     */
    last: boolean;
    /**
     * Returns true if there is previous page/strip available.
     */
    hasPrevious: boolean;
    /**
     * Returns true if there is next page/strip available.
     */
    hasNext: boolean;
    /**
     * Returns true if there is only single page/strip available (i.e. total record count < record count on one page).
     */
    singlePage: boolean;
    /**
     * Returns true if there are no data available.
     */
    empty: boolean;
}
/**
 * Generic evitaDB-wise entity containing all possible data.
 */
export interface Entity {
    /**
     * Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large binary arrays representing entire files (i.e. pictures, documents).
     */
    associatedData?: any;
    /**
     * The references represent relations to other evitaDB entities or external entities in different systems.
     */
    references?: any;
    /**
     *
     */
    parentEntity?: Entity;
    /**
     *
     */
    priceInnerRecordHandling: PriceInnerRecordHandling;
    /**
     * Type of entity. Entity type is main sharding key - all data of entities with same type are stored in separated collections. Within the entity type entity is uniquely represented by primary key.
     */
    type: string;
    /**
     * Contains version of this definition object and gets increased with any entity type update. Allows to execute optimistic locking i.e. avoiding parallel modifications.
     */
    version: number;
    /**
     * Contains set of all locales that were used for localized attributes or associated data of this particular entity.
     */
    allLocales: Array<string>;
    /**
     *
     */
    priceForSale?: Price;
    /**
     * Contains set of requested locales for this particular entity.
     */
    locales: Array<string>;
    /**
     * Attributes allows defining set of data that are fetched in bulk along with the reference. Attributes may be used for fast filtering or can be used to sort along.
     */
    attributes?: any;
    /**
     * Prices allows defining set of prices of entity for complex filtering and ordering.
     */
    prices: Array<Price>;
    /**
     * Unique Integer positive number representing the entity. Can be used for fast lookup for entity (entities). Primary key must be unique within the same entity type.
     */
    primaryKey: number;
}
/**
 * This is the definition object for entity. Definition objects allow to describe the structure of the entity type so that in any time everyone can consult complete structure of the entity type.  Based on our experience we've designed following data model for handling entities in evitaDB. Model is rather complex but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject to search.  Minimal entity definition consists of: - entity type and - primary key (even this is optional and may be autogenerated by the database).  Other entity data is purely optional and may not be used at all.
 */
export interface EntitySchema {
    /**
     *
     */
    associatedData: AssociatedDataSchemas;
    /**
     *
     */
    references: ReferenceSchemas;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * Contains `true` when primary keys of entities of this type will not be provided by the external systems and Evita is responsible for generating unique primary keys for the entity on insertion.  Generated key is guaranteed to be unique, but may not represent continuous ascending series. Generated key will be always greater than zero.
     */
    withGeneratedPrimaryKey: boolean;
    /**
     * Contains version of this definition object and gets increased with any entity type update. Allows to execute optimistic locking i.e. avoiding parallel modifications.
     */
    version: number;
    /**
     * Evolution mode allows to specify how strict is evitaDB when unknown information is presented to her for the first time. When no evolution mode is set, each violation of the `EntitySchema` is reported by an exception. This behaviour can be changed by this evolution mode however.
     */
    evolutionMode: Array<string>;
    /**
     * Contains `true` when entities of this type are organized in a tree like structure (hierarchy) where certain entities are subordinate of other entities.  Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be referred by multiple child entities. Hierarchy is always composed of entities of same type. Each entity must be part of at most single hierarchy (tree).  Hierarchy can limit returned entities by using filtering constraints. It's also used for computation of extra data - such as `hierarchyParentsOfSelf`. It can also invert type of returned entities in case extra result `hierarchyOfSelf` is requested.
     */
    withHierarchy: boolean;
    /**
     * Contains `true` when entities of this type holds price information.  Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce systems and highly affects performance of the entities filtering and sorting, they deserve first class support in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different customers.  Specifying prices on entity allows usage of `priceValidIn`, `priceInCurrency` `priceBetween`, and `priceInPriceLists` filtering constraints and also `priceNatural`, ordering of the entities. Additional extra result `priceHistogram` and requirement `priceType` can be used in query as well.
     */
    withPrice: boolean;
    /**
     * Determines how many fractional places are important when entities are compared during filtering or sorting. It is important to know that all prices will be converted to `Int`, so any of the price values (either with or without tax) must not ever exceed maximum limits of `Int` type when scaling the number by the power of ten using `indexedPricePlaces` as exponent.
     */
    indexedPricePlaces: number;
    /**
     * Contains set of all `Locale` that could be used for localized `AttributeSchema` or `AssociatedDataSchema`. Enables using `entityLocaleEquals` filtering constraint in query.
     */
    locales: Array<string>;
    /**
     *
     */
    sortableAttributeCompounds: SortableAttributeCompoundSchemas;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
    /**
     *
     */
    attributes: AttributeSchemas;
    /**
     * Contains set of all `Currency` that could be used for `prices` in entities of this type.
     */
    currencies: Array<string>;
}
/**
 * Contains all available entity schemas.
 */
export interface EntitySchemas extends Record<string, EntitySchema> {
    [key: string]: EntitySchema;

}
/**
 * Map of requested extra results besides actual found records.
 */
export interface ExtraResults {
    /**
     *
     */
    hierarchy?: Hierarchy;
    /**
     *
     */
    queryTelemetry: QueryTelemetry;
    /**
     *
     */
    facetSummary?: FacetSummary;
    /**
     *
     */
    priceHistogram?: Histogram;
    /**
     *
     */
    attributeHistogram?: AttributeHistogram;
}
/**
 * This DTO contains information about single facet group and statistics of the facets that relates to it.
 */
export interface FacetGroupStatistics {
    /**
     * Contains number of distinct entities in the response that possess any reference in this group.
     */
    count: number;
    /**
     *
     */
    groupEntity?: Entity;
    /**
     * Contains statistics of individual facets.
     */
    facetStatistics: Array<FacetStatistics>;
}
/**
 *  This DTO contains information about the impact of adding respective facet into the filtering constraint. This  would lead to expanding or shrinking the result response in certain way, that is described in this DTO.  This implementation contains only the bare difference and the match count.
 */
export interface FacetRequestImpact {
    /**
     * Selection has sense - TRUE if there is at least one entity still present in the result if the query is altered by adding this facet to filtering constraint.
     */
    hasSense: boolean;
    /**
     * Projected number of filtered entities if the query is altered by adding this facet to filtering constraint.
     */
    matchCount: number;
    /**
     * Projected number of entities that are added or removed from result if the query is altered by adding this facet to filtering constraint in comparison to current result.
     */
    difference: number;
}
/**
 * This DTO contains information about single facet statistics of the entities that are present in the response.
 */
export interface FacetStatistics {
    /**
     *
     */
    impact?: FacetRequestImpact;
    /**
     * Contains number of distinct entities in the response that possess of this reference.
     */
    count: number;
    /**
     *
     */
    facetEntity?: Entity;
    /**
     * Contains TRUE if the facet was part of the query filtering constraints.
     */
    requested: boolean;
}
/**
 * This DTO allows returning summary of all facets that match query filter excluding those inside `userFilter`. DTO contains information about facet groups and individual facets in them as well as appropriate statistics for them.
 */
export interface FacetSummary extends Record<string, FacetGroupStatistics> {
    [key: string]: FacetGroupStatistics;

}

export interface EntityAttributeSchema {
    /**
     * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies (memory/disk) space in the form of index.  When attribute is filterable, extra result `attributeHistogram` can be requested for this attribute.
     */
    filterable: boolean;
    /**
     * When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce non-null checks upon upserting of the entity.
     */
    nullable: boolean;
    /**
     * Whether this attribute can be used to represent an entire entity.
     */
    representative: boolean;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Default value is used when the entity is created without this attribute specified. Default values allow to pass non-null checks even if no attributes of such name are specified.
     */
    defaultValue?: string | number | boolean | Array<any> | any;
    /**
     * When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
     */
    localized: boolean;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies (memory/disk) space in the form of index..
     */
    sortable: boolean;
    /**
     * Data type of the attribute. Must be one of Evita-supported values. Internally the scalar is converted into Java-corresponding data type.
     */
    type: string;
    /**
     * Determines how many fractional places are important when entities are compared during filtering or sorting. It is significant to know that all values of this attribute will be converted to `Int`, so the attribute number must not ever exceed maximum limits of `Int` type when scaling the number by the power of ten using `indexedDecimalPlaces` as exponent.
     */
    indexedDecimalPlaces: number;
    /**
     * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity having certain value of this attribute among other entities in the same collection.  As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's better to have this ensured by the database engine.
     */
    uniquenessType: AttributeUniquenessType;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
}
/**
 * This is the definition object for attributes that are stored along with catalog. Definition objects allow to describe the structure of the catalog so that in any time everyone can consult complete structure of the catalog. Definition object is similar to Java reflection process where you can also at any moment see which fields and methods are available for the class.  Catalog attributes allows defining set of data that are fetched in bulk along with the catalog body. Attributes may be indexed for fast filtering or can be used to sort along. Attributes are not automatically indexed in order not to waste precious memory space for data that will never be used in search queries.  Filtering in attributes is executed by using constraints like `and`, `or`, `not`, `attribute_{name}_equals`, `attribute_{name}_contains` and many others. Sorting can be achieved with `attribute_{name}_natural` or others.  Attributes are not recommended for bigger data as they are all loaded at once when requested.
 */
export interface GlobalAttributeSchema {
    /**
     * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies (memory/disk) space in the form of index.  When attribute is filterable, extra result `attributeHistogram` can be requested for this attribute.
     */
    filterable: boolean;
    /**
     * When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce non-null checks upon upserting of the entity.
     */
    nullable: boolean;
    /**
     * Whether this attribute can be used to represent an entire entity.
     */
    representative: boolean;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Default value is used when the entity is created without this attribute specified. Default values allow to pass non-null checks even if no attributes of such name are specified.
     */
    defaultValue?: string | number | boolean | Array<any> | any;
    /**
     * When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
     */
    localized: boolean;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies (memory/disk) space in the form of index..
     */
    sortable: boolean;
    /**
     * Data type of the attribute. Must be one of Evita-supported values. Internally the scalar is converted into Java-corresponding data type.
     */
    type: string;
    /**
     * Determines how many fractional places are important when entities are compared during filtering or sorting. It is significant to know that all values of this attribute will be converted to `Int`, so the attribute number must not ever exceed maximum limits of `Int` type when scaling the number by the power of ten using `indexedDecimalPlaces` as exponent.
     */
    indexedDecimalPlaces: number;
    /**
     * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity having certain value of this attribute among other entities in the same collection.  As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's better to have this ensured by the database engine.
     */
    uniquenessType: AttributeUniquenessType;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
    /**
     * When attribute is unique globally it is automatically filterable, and it is ensured there is exactly one single          entity having certain value of this attribute in entire catalog.           As an example of unique attribute can be URL - there is no sense in having two entities with same URL, and it's          better to have this ensured by the database engine.
     */
    globalUniquenessType: GlobalAttributeUniquenessType;
}
/**
 * Contains all global attributes schemas relevant for parent schema.
 */
export interface GlobalAttributeSchemas extends Record<string, GlobalAttributeSchema> {
    [key: string]: GlobalAttributeSchema;

}
/**
 * This DTO contains hierarchical structures of self hierarchical as well as entities referenced by the entities required by the query. It copies hierarchical structure of those entities and contains their identification or full body as well as information on cardinality of referencing entities.
 */
export interface Hierarchy extends Record<string, Array<LevelInfo>> {
    [key: string]: Array<LevelInfo>;

}
/**
 * A histogram is an approximate representation of the distribution of numerical data. For detailed description please see [Wikipedia](https://en.wikipedia.org/wiki/Histogram). Histogram can be computed only for numeric based properties. It visualises which property values are more common in the returned data set and which are rare. Bucket count will never exceed requested bucket count but there may be less of them if there is no enough data for computation. Bucket thresholds are specified heuristically so tha there are as few \"empty buckets\" as possible.  - buckets are defined by their lower bounds (inclusive) - the upper bound is the lower bound of the next bucket
 */
export interface Histogram {
    /**
     * Returns count of all entities that are covered by this histogram. It's plain sum of occurrences of all buckets in the histogram.
     */
    overallCount: number;
    /**
     * Returns right bound of the last bucket of the histogram. Each bucket contains only left bound threshold, so this value is necessary so that first histogram buckets makes any sense. This value is exceptional in the sense that it represents the biggest value encountered in the returned set and represents inclusive right bound for the last bucket.
     */
    max: string;
    /**
     * Returns histogram buckets that represents a tuple of occurrence count and the minimal threshold of the bucket values.
     */
    buckets: Array<HistogramBucket>;
    /**
     * Returns left bound of the first bucket. It represents the smallest value encountered in the returned set.
     */
    min: string;
}
/**
 * Data object that carries out threshold in histogram (or bucket if you will) along with number of occurrences in it.
 */
export interface HistogramBucket {
    /**
     * Contains number of entity occurrences in this bucket - e.g. number of entities that has monitored property value between previous bucket threshold (exclusive) and this bucket threshold (inclusive)
     */
    occurrences: number;
    /**
     * Contains index (starting with zero) of the bucket in the histogram. First bucket / column of the histogram will have index zero, second bucket / column one and so forth.
     */
    index: number;
    /**
     * Contains threshold (left bound - inclusive) of the bucket.
     */
    threshold: string;
}
/**
 * This DTO represents single hierarchical entity in the hierarchy tree. It contains identification of the entity, the cardinality of queried entities that refer to it and information about children level.
 */
export interface LevelInfo {
    /**
     * Contains the number of queried entities that refer directly to this {@link #entity} or to any of its children entities.
     */
    queriedEntityCount: number;
    /**
     * Whether this hierarchical entity has any child entities.
     */
    children: Array<LevelInfo>;
    /**
     *
     */
    entity: Entity;
    /**
     * Contains number of hierarchical entities that are referring to this `entity` as its parent. The count will respect behaviour settings and will not count empty children in case `REMOVE_EMPTY` is used for computation.
     */
    childrenCount: number;
}
/**
 * API error.
 */
export interface ModelError {
    /**
     *          Error code classifying error.
     */
    errorCode: string;
    /**
     * Descriptive message of exception for client.
     */
    message: string;
}
/**
 * Contains all name variants of parent object.
 */
export interface NameVariants {
    /**
     * [Capitalized snake case variant](https://en.wikipedia.org/wiki/Snake_case)
     */
    upperSnakeCase: string;
    /**
     * [Kebab case variant](https://en.wikipedia.org/wiki/Letter_case#Kebab_case)
     */
    kebabCase: string;
    /**
     * [Pascal case variant](https://www.theserverside.com/definition/Pascal-case)
     */
    pascalCase: string;
    /**
     * [Snake case variant](https://en.wikipedia.org/wiki/Snake_case)
     */
    snakeCase: string;
    /**
     * [Camel case variant](https://en.wikipedia.org/wiki/Camel_case)
     */
    camelCase: string;
}

export enum OrderBehaviour {
    NullsFirst = 'NULLS_FIRST',
    NullsLast = 'NULLS_LAST'
}

export enum OrderDirection {
    Asc = 'ASC',
    Desc = 'DESC'
}
/**
 * Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce systems and highly affects performance of the entities filtering and sorting, they deserve first class support in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different customers.
 */
export interface Price {
    /**
     * Some special products (such as master products, or product sets) may contain prices of all \"subordinate\" products so that the aggregating product can represent them in certain views on the product. In that case there is need to distinguish the projected prices of the subordinate product in the one that represents them. Inner record id must contain positive value.
     */
    innerRecordId?: number;
    /**
     * Price with tax.
     */
    priceWithTax: string;
    /**
     * Controls whether price is subject to filtering / sorting logic, non-sellable prices will be fetched along with entity but won't be considered when evaluating search. These prices may be used for \"informational\" prices such as reference price (the crossed out price often found on e-commerce sites as \"usual price\") but are not considered as the \"selling\" price.
     */
    sellable: boolean;
    /**
     * Contains identification of the price list in the external system. Each price must reference a price list. Price list identification may refer to another Evita entity or may contain any external price list identification (for example id or unique name of the price list in the external system). Single entity is expected to have single price for the price list unless there is validity specified. In other words there is no sense to have multiple concurrently valid prices for the same entity that have roots in the same price list.
     */
    priceList: string;
    /**
     * Tax rate percentage (i.e. for 19% it'll be 19.00)
     */
    taxRate: string;
    /**
     * Price without tax.
     */
    priceWithoutTax: string;
    /**
     * Identification of the currency.
     */
    currency: string;
    /**
     * Date and time interval for which the price is valid (inclusive).
     */
    validity?: Array<Date>;
    /**
     * Contains identification of the price in the external systems. This id is expected to be used for the synchronization of the price in relation with the primary source of the prices. This id is used to uniquely find a price within same price list and currency and is mandatory.
     */
    priceId: number;
}

export enum PriceInnerRecordHandling {
    None = 'NONE',
    FirstOccurrence = 'FIRST_OCCURRENCE',
    Sum = 'SUM',
    Unknown = 'UNKNOWN'
}
/**
 * Request body for querying entities.
 */
export interface QueryEntitiesRequestBody {
    /**
     * Named arguments for query.
     */
    namedArguments: any;
    /**
     * Query in EvitaQL language
     */
    query: string;
    /**
     * Positional arguments for query.
     */
    positionalArguments: Array<string | number | boolean | Array<any> | any>;
}

export enum QueryPhase {
    Overall = 'OVERALL',
    Planning = 'PLANNING',
    PlanningNestedQuery = 'PLANNING_NESTED_QUERY',
    PlanningIndexUsage = 'PLANNING_INDEX_USAGE',
    PlanningFilter = 'PLANNING_FILTER',
    PlanningFilterNestedQuery = 'PLANNING_FILTER_NESTED_QUERY',
    PlanningFilterAlternative = 'PLANNING_FILTER_ALTERNATIVE',
    PlanningSort = 'PLANNING_SORT',
    PlanningSortAlternative = 'PLANNING_SORT_ALTERNATIVE',
    PlanningExtraResultFabrication = 'PLANNING_EXTRA_RESULT_FABRICATION',
    PlanningExtraResultFabricationAlternative = 'PLANNING_EXTRA_RESULT_FABRICATION_ALTERNATIVE',
    Execution = 'EXECUTION',
    ExecutionPrefetch = 'EXECUTION_PREFETCH',
    ExecutionFilter = 'EXECUTION_FILTER',
    ExecutionFilterNestedQuery = 'EXECUTION_FILTER_NESTED_QUERY',
    ExecutionSortAndSlice = 'EXECUTION_SORT_AND_SLICE',
    ExtraResultsFabrication = 'EXTRA_RESULTS_FABRICATION',
    ExtraResultItemFabrication = 'EXTRA_RESULT_ITEM_FABRICATION',
    Fetching = 'FETCHING',
    FetchingReferences = 'FETCHING_REFERENCES',
    FetchingParents = 'FETCHING_PARENTS'
}
/**
 * This DTO contains detailed information about query processing time and its decomposition to single operations.
 */
export interface QueryTelemetry {
    /**
     *          Date and time of the start of this step in nanoseconds.
     */
    start: string;
    /**
     * Internal steps of this telemetry step (operation decomposition).
     */
    steps: Array<QueryTelemetry>;
    /**
     * Duration in nanoseconds.
     */
    spentTime: string;
    /**
     * Arguments of the processing phase.
     */
    arguments: Array<string>;
    /**
     *
     */
    operation: QueryPhase;
}
/**
 * Page of records according to pagination rules in input query.
 */
export interface RecordPage extends DataChunk {
    /**
     * Returns current page number (indexed from 1).
     */
    pageNumber: number;
    /**
     * Returns number of records per single page.
     */
    pageSize: number;
    /**
     * Returns offset of the last record of current page with current pageSize.
     */
    lastPageItemNumber: number;
    /**
     * Returns offset of the first record of current page with current pageSize.
     */
    firstPageItemNumber: number;
    /**
     * Returns number of the last page that can be accessed with current number of records. Returns -1 when offset/limit was used for creating paginated list.
     */
    lastPageNumber: number;
}
/**
 * Strip of records according to offset and limit rules in input query.
 */
export interface RecordStrip extends DataChunk {
    /**
     * Returns current offset (indexed from 0).
     */
    offset: number;
    /**
     * Returns limit - i.e. maximal number of records that are requested after offset.
     */
    limit: number;
}
/**
 * This is the definition object for reference that is stored along with entity. Definition objects allow to describe the structure of the entity type so that in any time everyone can consult complete structure of the entity type.  The references refer to other entities (of same or different entity type). Allows entity filtering (but not sorting) of the entities by using `facet_{name}_inSet` query and statistics computation if when requested. Reference is uniquely represented by int positive number (max. 2<sup>63</sup>-1) and entity type and can be part of multiple reference groups, that are also represented by int and entity type.  Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part of different reference groups. Referenced entity type may represent type of another Evita entity or may refer to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment, group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in Evita.  References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
 */
export interface ReferenceSchema {
    /**
     *
     */
    groupTypeNameVariants?: NameVariants;
    /**
     * Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
     */
    referencedEntityTypeManaged: boolean;
    /**
     * Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
     */
    referencedGroupTypeManaged?: boolean;
    /**
     * Contains `true` if the index for this reference should be created and maintained allowing to filter by `reference_{reference name}_having` filtering constraints. Index is also required when reference is `faceted`.  Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference. Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed, the entity cannot be looked up by reference attributes or relation existence itself, but the data can be fetched.
     */
    indexed: boolean;
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     *
     */
    entityTypeNameVariants: NameVariants;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * Attributes related to reference allows defining set of data that are fetched in bulk along with the entity body. Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along (`AttributeSchema.filterable`). Attributes are not automatically indexed in order not to waste precious memory space for data that will never be used in search queries.  Filtering in attributes is executed by using constraints like `and`, `not`, `attribute_{name}_equals`, `attribute_{name}_contains` and many others. Sorting can be achieved with `attribute_{name}_natural` or others.  Attributes are not recommended for bigger data as they are all loaded at once.
     */
    attributes: AttributeSchemas;
    /**
     *
     */
    cardinality: Cardinality;
    /**
     * Contains `true` if the statistics data for this reference should be maintained and this allowing to get `facetStatistics` for this reference or use `facet_{reference name}_inSet` filtering constraint.  Do not mark reference as faceted unless you want it among `facetStatistics`. Each faceted reference occupies (memory/disk) space in the form of index.  Reference that was marked as faceted is called Facet.
     */
    faceted: boolean;
    /**
     * Reference to `Entity.type` of the referenced entity. Might be also any `String` that identifies type some external resource not maintained by Evita.
     */
    referencedEntityType: string;
    /**
     * Reference to `Entity.type` of the referenced entity. Might be also `String` that identifies type some external resource not maintained by Evita.
     */
    referencedGroupType?: string;
    /**
     * Contains definitions of all sortable attribute compounds defined in this schema.
     */
    sortableAttributeCompounds: SortableAttributeCompoundSchemas;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
}
/**
 * Contains all reference schemas relevant for parent schema.
 */
export interface ReferenceSchemas extends Record<string, ReferenceSchema> {
    [key: string]: ReferenceSchema;

}
/**
 * Evita response contains all results to single query. Results are divided to two parts - main results returned by `recordPage`/`recordStrip` and set of extra results retrieved by `extraResults`.
 */
export interface Response {
    /**
     *
     */
    extraResults: ExtraResults;
    /**
     *
     */
    recordPage: DataChunk;
}
/**
 * Sortable attribute compounds are used to sort entities or references by multiple attributes at once. evitaDB requires a pre-sorted index in order to be able to sort entities or references by particular attribute or combination of attributes, so it can deliver the results as fast as possible. Sortable attribute compounds are filtered the same way as attributes - using natural ordering constraint.
 */
export interface SortableAttributeCompoundSchema {
    /**
     * Deprecation notice contains information about planned removal of this entity from the model / client API. This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.  If notice is `null`, this schema is considered not deprecated.
     */
    deprecationNotice?: string;
    /**
     * Contains description of the model is optional but helps authors of the schema / client API to better explain the original purpose of the model to the consumers.
     */
    description?: string;
    /**
     * Contains unique name of the model. Case-sensitive. Distinguishes one model item from another within single entity instance.
     */
    name: string;
    /**
     *
     */
    nameVariants: NameVariants;
    /**
     * Collection of attribute elements that define the sortable compound. The order of the elements is important, as it defines the order of the sorting.
     */
    attributeElements: Array<AttributeElement>;
}
/**
 * Contains all sortable attribute compound schemas relevant for parent schema.
 */
export interface SortableAttributeCompoundSchemas extends Record<string, SortableAttributeCompoundSchema> {
    [key: string]: SortableAttributeCompoundSchema;
}

export enum QueryPriceMode {
    WithTax = 'WITH_TAX',
    WithoutTax = 'WITHOUT_TAX'
}

export type Range<T extends DateTime | BigDecimal | Long | number> = [T | undefined, T | undefined]
