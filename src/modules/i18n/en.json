{
  "app": {
    "name": "evitaLab"
  },
  "common": {
    "placeholder": {
      "empty": "<empty>",
      "emptyArray": "<empty array>",
      "null": "<null>",
      "yes": "Yes",
      "no": "No"
    },
    "button": {
      "previous": "Previous",
      "next": "Next",
      "close": "Close",
      "cancel": "Cancel",
      "remove": "Remove",
      "save": "Save",
      "run": "Run",
      "add": "Add",
      "create": "Create",
      "drop": "Drop",
      "delete": "Delete",
      "executeQuery": "Execute query",
      "showMore": "Show more",
      "copy": "Copy",
      "confirm": "Confirm",
      "rename": "Rename",
      "replace": "Replace",
      "switch": "Switch",
      "accept": "Accept",
      "reload": "Reload"
    },
    "notification": {
      "copiedToClipboard": "Copied to clipboard",
      "failedToCopyToClipboard": "Failed to copy to clipboard"
    },
    "list": {
      "empty": "No items found."
    },
    "statusBar": {
      "activeEditorStatus": {
        "selections": {
          "label": "Text selections in the active editor",
          "value": {
            "multipleSelections": "{count} selections",
            "singleSelection": {
              "cursorPosition": "Ln {line}, Col {column}",
              "selectionRange": "{charsCount} chars",
              "lineBreaks": "{lineBreaks} line breaks"
            }
          }
        },
        "tabSize": {
          "label": "Current tab size configuration in the active editor",
          "value": "{tabSize} spaces"
        },
        "language": {
          "label": "Supported language in the active editor"
        }
      }
    },
    "dialog": {
      "confirmDialog": {
        "title": "Dangerous operation",
        "message": "Warning! You are about to do dangerous operation. Are you sure you want to proceed?"
      }
    },
    "input": {
      "dateTime": {
        "timeOffset": {
          "title": "Select time offset",
          "hours": "Hours",
          "minutes": "Minutes"
        },
        "help": {
          "timeOffset": "in time offset of {offset}"
        },
        "error": {
          "olderThanMin": "Date time is older than the minimum allowed.",
          "newerThanMax": "Date time is newer than the maximum allowed."
        }
      }
    }
  },
  "panel": {
    "button": {
      "manage": "Manage evitaLab"
    },
    "manage": {
      "manage": {
        "title": "Manage",
        "item": {
          "keymap": "Keymap"
        }
      },
      "evitaLabHelp": {
        "title": "evitaLab Help",
        "item": {
          "evitaLabGithub": "evitaLab GitHub",
          "discussEvitaLab": "Discuss evitaLab",
          "reportEvitaLabIssue": "Report evitaLab issue"
        }
      },
      "evitaDBHelp": {
        "title": "evitaDB Help",
        "item": {
          "evitaDBDocumentation": "evitaDB Documentation",
          "evitaDBGithub": "evitaDB GitHub",
          "discussEvitaDB": "Discuss evitaDB",
          "reportEvitaDBIssue": "Report evitaDB issue"
        }
      }
    },
    "link": {
      "evitaDBDocumentation": {
        "icon": {
          "alt": "evitaDB Documentation"
        },
        "tooltip": "Open evitaDB documentation"
      },
      "discord": {
        "icon": {
          "alt": "Discord"
        },
        "tooltip": "Discuss on Discord"
      }
    }
  },
  "welcomeScreen": {
    "standalone": {
      "changelog": "changelog",
      "description": "evitaDB web client",
      "blog": {
        "thumbnail": {
          "alt": "Image - {title}"
        },
        "button": {
          "read": "Read"
        }
      },
      "link": {
        "evitaDBDocumentation": {
          "text": "Check out the {link}",
          "link": "evitaDB documentation"
        },
        "evitaLabGitHub": {
          "text": "Give us a ‚≠ê on {link}",
          "link": "GitHub"
        },
        "discord": {
          "text": "Reach out to us on {link}",
          "link": "Discord"
        },
        "submitIssue": "Submit an issue"
      }
    },
    "driver": {
      "changelog": "changelog",
      "description": "driver"
    }
  },
  "tab": {
    "button": {
      "closeTab": "Close tab"
    },
    "placeholder": {
      "loading": "Loading, please wait ..."
    }
  },
  "tabShare": {
    "button": {
      "shareTab": "Share this tab"
    },
    "tooltip": {
      "nonSharableTab": "Cannot share this tab because it is using a user-defined evitaDB connection. Only pre-configured connections can be shared."
    },
    "sharedDialog": {
      "title": "Shared tab found",
      "text": {
        "withoutInitialData": "The URL contains an embedded query from an unknown source. Do you want to open it? If you accept, evitaLab will <em>open a new tab</em> with the query, but will <em>not</em> execute it automatically. You can still decide if you want to execute it. If you reject, the query in the URL will be <em>discarded</em>.",
        "withInitialData": "The URL contains an embedded shared tab from an unknown source. Do you want to open it? If you accept it, evitaLab will <em>open a new tab</em> with the query. If you reject it, it will be <em>discarded</em>."
      },
      "warning": {
        "potentiallyUnsafe": "<em>Be careful!</em> The query in the URL may contain potentially malicious code."
      }
    },
    "sharedTroubleshooterDialog": {
      "title": "Shared tab is broken",
      "info": "Discovered shared tab contains data that are not available in this evitaLab instance. Please choose data that are available below.",
      "form": {
        "newConnectionId": {
          "label": "New connection",
          "hint": {
            "connectionMatchedByName": "The exact connection from shared tab is not available. However connection with similar name is available.",
            "connectionNotMatchedByName": "The connection from shared tab is not available. However you can try to use the current one."
          }
        }
      }
    },
    "shareDialog": {
      "title": "Share this tab",
      "text": "You can share this tab and its data with other users via a link. This link will open a new instance of evitaLab on their device and load this tab with the same query, which should give the same output as you see now.",
      "notification": {
        "linkCopied": "Link copied to clipboard."
      },
      "warning": {
        "sensitiveData": "Be <em>careful</em> if you have sensitive data in the query, you are giving them away embedded in the link. Once you send the link, you lose control over it and it can be opened by <em>anyone</em> who has access to this evitaLab instance.",
        "linkMayNotWork": "The link may <em>not</em> work in certain browsers due to its length exceeding {{ urlCharacterLimit }} characters."
      },
      "button": {
        "copyLink": "Copy link"
      }
    }
  },
  "command": {
    "system": {
      "_title": "System",
      "keymap": "Keymap",
      "panels": {
        "_title": "Panels",
        "connection": "Connection"
      },
      "editor": {
        "_title": "Editor",
        "previousTab": "Previous tab",
        "nextTab": "Next tab",
        "closeTab": "Close tab",
        "closeAllTabs": "Close all tabs"
      }
    },
    "queryEditor": {
      "_title": "Query editor",
      "moveLineUp": "Move line up",
      "moveLineDown": "Move line down",
      "copyLineUp": "Copy line up",
      "copyLineDown": "Copy line down",
      "simplifySelection": "Simplify selection",
      "selectLine": "Select line",
      "selectParentSyntax": "Select parent syntax",
      "indentLess": "Indent less",
      "indentMore": "Indent more",
      "indentSelection": "Indent selection",
      "deleteLine": "Delete line",
      "cursorMatchingBracket": "Cursor matching bracket",
      "toggleComment": "Toggle comment",
      "toggleBlockComment": "Toggle block comment"
    },
    "inlineQueryEditor": {
      "_title": "Inline query editor",
      "openHistory": "Open history"
    },
    "entityViewer": {
      "_title": "Entity grid",
      "executeQuery": "Execute query",
      "changeQueryLanguage": "Change query language",
      "filterBy": "Filter by",
      "orderBy": "Order by",
      "changeDataLocale": "Change data locale",
      "changePriceType": "Change price type",
      "shareTab": "Share tab",
      "openPropertySelector": "Open property selector",
      "scopeSelector": {
        "title": "Select scope",
        "live": "In Live scope",
        "archive": "In Archive scope"
      },
      "toolbar": {
        "live": "In Live scope",
        "archive": "In Archive scope"
      },
      "propertySelector": {
        "_title": "Property selector",
        "findProperty": "Find property"
      },
      "entityGrid": {
        "entityGridCell": {
          "rawCopyToolTip": "Shift + Middle mouse button",
          "rawCopyToolTipDescription": "Copy raw value from cell",
          "copyValueToolTip": "Middle mouse button",
          "copyValueToolTipDescription": "Copy value from cell"
        }
      }
    },
    "evitaQLConsole": {
      "_title": "evitaQL console",
      "executeQuery": "Execute query",
      "shareTab": "Share tab",
      "query": {
        "_title": "Query",
        "queryEditor": "Query editor",
        "variablesEditor": "Variables editor",
        "history": "History"
      },
      "result": {
        "_title": "Result",
        "rawResultViewer": "Raw result viewer",
        "resultVisualizer": "Result visualizer"
      }
    },
    "graphQLConsole": {
      "_title": "GraphQL console",
      "executeQuery": "Execute query",
      "shareTab": "Share tab",
      "query": {
        "_title": "Query",
        "queryEditor": "Query editor",
        "variablesEditor": "Variables editor",
        "history": "History",
        "schemaViewer": "Schema viewer"
      },
      "result": {
        "_title": "Result",
        "rawResultViewer": "Raw result viewer",
        "resultVisualizer": "Result visualizer"
      }
    },
    "schemaViewer": {
      "_title": "Schema viewer",
      "shareTab": "Share tab"
    },
    "trafficRecordHistoryViewer": {
      "_title": "Traffic record history viewer",
      "shareTab": "Share tab",
      "reloadRecordHistory": "Reload record history",
      "moveStartPointer": "Load only records newer than now"
    }
  },
  "explorer": {
    "title": "Connection Explorer",
    "readOnlyToolTip": "Server is read-only",
    "button": {
      "connect": "Connect"
    },
    "connection": {
      "flag": {
        "preconfigured": "preconfigured"
      },
      "menu": {
        "item": {
          "manageSubheader": "Manage",
          "modifySubheader": "Modify",
          "catalogsSubheader": "Catalogs",
          "graphQLSystemApiConsole": "GraphQL System API console",
          "create": "Create catalog",
          "edit": "Edit connection",
          "remove": "Remove connection",
          "reload": "Reload",
          "server": "Server",
          "createCatalog": "Create catalog",
          "catalogBackups": "Catalog backups",
          "tasks": "Tasks",
          "jfrRecordings": "JFR recordings",
          "trafficRecordings": "Traffic recordings"
        }
      },
      "notification": {
        "couldNotLoadCatalogs": "Could not load catalogs: {reason}",
        "couldNotLoadServerStatus": "Could not load server status: {reason}"
      }
    },
    "catalog": {
      "flag": {
        "corrupted": "corrupted",
        "warmingUp": "warming up",
        "alive": "alive",
        "beingActivated": "Being activated {0}%",
        "beingCreated": "Being created",
        "beingDeactivated": "Being deactivated {0}%",
        "beingDeleted": "Being deleted",
        "goingAlive": "Going alive",
        "inactive": "Inactive",
        "duplication": "Duplicating - {0}%",
        "renaming": "Renaming - {0}%",
        "replacing": "Replacing - {0}%",
        "activation": "Activating - {0}%",
        "deactivation": "Deactivating - {0}%"
      },
      "title": {
        "readOnly": "catalog is read-only"
      },
      "menu": {
        "item": {
          "manageSubheader": "Manage",
          "modifySubheader": "Modify",
          "collectionsSubheader": "Collections",
          "trafficSubheader": "Traffic",
          "evitaQLConsole": "evitaQL console",
          "graphQLDataApiConsole": "GraphQL Data API console",
          "graphQLSchemaApiConsole": "GraphQL Schema API console",
          "viewSchema": "Schema",
          "backup": "Backup",
          "closeSharedSession": "Close shared session",
          "deleteCatalog": "Delete catalog",
          "renameCatalog": "Rename catalog",
          "duplicateCatalog": "Duplicate catalog",
          "replaceCatalog": "Replace catalog",
          "createCollection": "Create collection",
          "switchCatalogToAliveState": "Switch catalog to alive state",
          "activeTrafficRecording": "Active traffic recording",
          "activateCatalog": "Activate catalog",
          "deactivateCatalog": "Deactivate catalog",
          "switchToMutable": "Switch to mutable",
          "switchToImmutable": "Switch to immutable"
        }
      },
      "notification": {
        "closedSharedSession": "Shared session of catalog {catalogName} was closed.",
        "couldNotCloseSharedSession": "Could not close shared session of catalog {catalogName}: {reason}"
      },
      "create": {
        "title": "Create catalog",
        "form": {
          "catalogName": {
            "label": "Catalog name",
            "validations": {
              "required": "Catalog name is required.",
              "empty": "Catalog name is required.",
              "leadingTrailingWhiteSpace": "Catalog name cannot have leading or trailing whitespace characters.",
              "keyword": "Catalog name is same as a reserved keyword.",
              "format": "Catalog name doesn't match supported format.",
              "notAvailable": "Catalog with this name already exists."
            }
          }
        },
        "notification": {
          "catalogCreated": "The {catalogName} catalog has been successfully created.",
          "couldNotCreateCatalog": "Could not create the {catalogName} catalog: {reason}"
        }
      },
      "delete": {
        "title": "Delete {catalogName} catalog",
        "question": "Do you want to delete the catalog?",
        "notification": {
          "catalogDeleted": "The {catalogName} catalog has been successfully deleted.",
          "catalogNotDeleted": "The {catalogName} catalog has been already deleted.",
          "couldNotDeleteCatalog": "Could not delete the {catalogName} catalog: {reason}"
        }
      },
      "duplication": {
        "title": "Duplicate {catalogName} catalog",
        "form": {
          "duplicationName": {
            "label": "New duplicated catalog name",
            "validations": {
              "required": "New name is required.",
              "empty": "New name is required.",
              "leadingTrailingWhiteSpace": "New name cannot have leading or trailing whitespace characters.",
              "keyword": "New name is same as a reserved keyword.",
              "format": "New name doesn't match supported format.",
              "notAvailable": "Catalog with this new name already exists."
            }
          },
          "buttons": {
            "duplicate": "Duplicate"
          }
        },
        "notification": {
          "catalogDuplicationStarted": "Duplication of {catalogName} catalog has started.",
          "catalogDuplicated": "The {catalogName} catalog has been successfully duplicated to {newCatalogName}.",
          "couldNotDuplicateCatalog": "Could not duplicate the {catalogName} catalog: {reason}"
        }
      },
      "rename": {
        "title": "Rename {catalogName} catalog",
        "form": {
          "newName": {
            "label": "New name",
            "validations": {
              "required": "New name is required.",
              "empty": "New name is required.",
              "leadingTrailingWhiteSpace": "New name cannot have leading or trailing whitespace characters.",
              "keyword": "New name is same as a reserved keyword.",
              "format": "New name doesn't match supported format.",
              "notAvailable": "Catalog with this new name already exists."
            }
          }
        },
        "notification": {
          "catalogRenameStarted": "Renaming of {catalogName} catalog has started.",
          "catalogRenamed": "The {catalogName} catalog has been successfully renamed to {newName}.",
          "couldNotRenameCatalog": "Could not rename catalog {catalogName}: {reason}"
        }
      },
      "replace": {
        "title": "Replace {catalogNameToBeReplaced} catalog",
        "info": "The {catalogNameToBeReplaced} catalog's data will be replaced with a data from the {catalogNameToBeReplacedWith} catalog under the {catalogNameToBeReplaced} name. The {catalogNameToBeReplacedWith} catalog will be deleted.",
        "form": {
          "catalogNameToBeReplacedWith": {
            "label": "With catalog",
            "validations": {
              "required": "Catalog is required.",
              "notExists": "This catalog doesn't exist anymore."
            }
          }
        },
        "notification": {
          "catalogReplacementStarted": "Replacement of {catalogNameToBeReplaced} catalog with {catalogNameToBeReplacedWith} has started.",
          "catalogReplaced": "The {catalogNameToBeReplaced} catalog has been successfully replaced with {catalogToBeReplacedWith}.",
          "catalogNotReplaced": "The {catalogNameToBeReplaced} catalog has not been replaced.",
          "couldNotReplaceCatalog": "Could not replace the {catalogNameToBeReplaced} catalog: {reason}"
        }
      },
      "switchToAliveState": {
        "title": "Switch {catalogName} catalog state",
        "description": "Switch the catalog's state from the warm up to the alive.",
        "warning": "Catalog in the alive state will no longer support bulk indexing. Instead, the catalog will use incremental indexing. However, it will support transactions and multiple parallel sessions.",
        "notification": {
          "catalogSwitchStarted": "Switching {catalogName} catalog from warm up to alive state has started.",
          "catalogSwitched": "The {catalogName} catalog has been switched from the warm up state to the alive state.",
          "couldNotSwitchCatalog": "Could not switch the {catalogName} catalog to the alive state: {reason}"
        }
      },
      "makeCatalogImmutable": {
        "title": "Switch {catalogName} catalog to immutable",
        "description": "Switch the catalog to the immutable state. In this state, no data modifications are allowed, and the catalog is read-only.",
        "notification": {
          "catalogImmutableSwitchStarted": "Switching {catalogName} catalog to immutable state has started.",
          "catalogMadeAsImmutable": "The {catalogName} catalog has been made as immutable",
          "couldNotMakeCatalogImmutable": "Could not make immutable the {catalogName} catalog: {reason}"
        },
        "buttons": {
          "makeCatalogImmutable": "Immutable"
        }
      },
      "makeCatalogMutable": {
        "title": "Switch {catalogName} catalog to mutable",
        "description": "Switch the catalog to the mutable state. In this state, data modifications are allowed again.",
        "notification": {
          "catalogMutableSwitchStarted": "Switching {catalogName} catalog to mutable state has started.",
          "catalogMadeAsMutable": "The {catalogName} catalog has been made as mutable",
          "couldNotMakeCatalogMutable": "Could not make mutable the {catalogName} catalog: {reason}"
        },
        "buttons": {
          "makeCatalogMutable": "Mutable"
        }
      },
      "deactivateCatalog": {
        "title": "Deactivate {catalogName}",
        "description": "Deactivate the catalog to temporarily prevent any operations on it. The catalog will remain in storage but won't be accessible.",
        "notification": {
          "catalogDeactivationStarted": "Deactivation of {catalogName} catalog has started.",
          "catalogDeactivated": "The {catalogName} catalog has been deactivated",
          "couldNotDeactivateCatalog": "Could not deactivate {catalogName} catalog: {reason}"
        },
        "buttons": {
          "deactivateCatalog": "Deactivate"
        }
      },
      "activateCatalog": {
        "title": "Activate {catalogName}",
        "description": "Activate the catalog to make it accessible again after it was deactivated.",
        "notification": {
          "catalogActivationStarted": "Activation of {catalogName} catalog has started.",
          "catalogActivated": "The {catalogName} catalog has been activated",
          "couldNotActivateCatalog": "Could not activate {catalogName} catalog: {reason}"
        },
        "buttons": {
          "activateCatalog": "Activate"
        }
      }
    },
    "collection": {
      "menu": {
        "item": {
          "modifySubheader": "Modify",
          "entities": "Entities",
          "schema": "Schema",
          "deleteCollection": "Delete collection",
          "renameCollection": "Rename collection"
        }
      },
      "create": {
        "title": "Create collection in {catalogName} catalog",
        "form": {
          "entityType": {
            "label": "Entity type",
            "validations": {
              "required": "Entity type is required.",
              "empty": "Entity type is required.",
              "leadingTrailingWhiteSpace": "Entity type cannot have leading or trailing whitespace characters.",
              "keyword": "Entity type is same as a reserved keyword.",
              "format": "Entity type doesn't match supported format.",
              "notAvailable": "Collection with this entity type already exists."
            }
          }
        },
        "notification": {
          "collectionCreated": "The {entityType} collection has been successfully created.",
          "couldNotCreateCollection": "Could not create the {entityType} collection: {reason}"
        }
      },
      "delete": {
        "title": "Delete {entityType} collection",
        "question": "Do you want to delete the collection?",
        "notification": {
          "collectionDeleted": "The {entityType} collection has been successfully deleted.",
          "collectionNotDeleted": "The {entityType} collection has been already deleted.",
          "couldNotDeleteCollection": "Could not delete the {entityType} collection: {reason}"
        }
      },
      "rename": {
        "title": "Rename {entityType} collection",
        "form": {
          "newName": {
            "label": "New name",
            "validations": {
              "required": "New name is required.",
              "empty": "New name is required.",
              "leadingTrailingWhiteSpace": "New name cannot have leading or trailing whitespace characters.",
              "keyword": "New name is same as a reserved keyword.",
              "format": "New name doesn't match supported format.",
              "notAvailable": "Collection with this new name already exists."
            }
          }
        },
        "notification": {
          "collectionRenamed": "The {entityType} collection has been successfully renamed to {newName}.",
          "collectionNotRenamed": "The {entityType} collection has not been renamed.",
          "couldNotRenameCollection": "Could not rename the {entityType} collection: {reason}"
        }
      }
    }
  },
  "keymapViewer": {
    "title": "Keymap"
  },
  "entityViewer": {
    "loadedDataWarning": "Loaded query data must be manually executed.",
    "notification": {
      "couldNotExecuteQuery": "Could not execute query"
    },
    "dataLocaleSelector": {
      "item": {
        "none": "None"
      }
    },
    "priceTypeSelector": {
      "WITH_TAX": "With tax",
      "WITHOUT_TAX": "Without tax"
    },
    "queryInput": {
      "notification": {
        "failedToSaveQueryToHistory": "Failed to save query to history."
      }
    },
    "layerSelector": {
      "live": "The default scope is where all new entities are created.",
      "archive": "The archive scope is where outdated entities that are no longer actively used are stored. The archive is usually covered by fewer indexes than the live scope and is not searched unless explicitly requested in a query."
    },
    "propertySelector": {
      "title": "Displayed properties",
      "label": {
        "filterProperties": "Filter properties"
      },
      "button": {
        "selectDisplayedProperties": "Select displayed properties"
      },
      "notification": {
        "invalidPropertySectionSelection": "Cannot select `Some` properties in a section."
      },
      "section": {
        "type": {
          "entity": "Entity",
          "attributes": "Attributes",
          "associatedData": "Associated data",
          "references": "References",
          "referenceAttributes": "Reference attributes",
          "prices": "Prices"
        },
        "button": {
          "openSchema": "Open schema"
        },
        "placeholder": {
          "noItemsForSearchedTerm": "No items found for searched term."
        }
      }
    },
    "grid": {
      "notification": {
        "failedToFindProperty": "Failed to find property descriptor for key: '{key}'",
        "failedToFindRequestedProperties": "These properties were requested but not found in current data: {keys}"
      },
      "cell": {
        "placeholder": {
          "noLocaleSelected": "<no locale selected>"
        },
        "detail": {
          "placeholder": {
            "invalidValue": "Invalid value.",
            "unknownProperty": "Unknown property"
          }
        }
      },
      "renderer": {
        "button": {
          "displayRawValue": "Display raw value",
          "prettyPrintValue": "Pretty print value",
          "selectOutputFormat": "Select output format"
        },
        "format": {
          "autoPrettyPrint": "Auto pretty print",
          "raw": "Raw value",
          "markdown": "Markdown",
          "json": "JSON",
          "xml": "XML",
          "html": "HTML"
        }
      },
      "codeRenderer": {
        "placeholder": {
          "failedToFormatValue": "Error: Failed to format value as {codeLanguage}. \\r\\n\\r\\n{message}"
        },
        "notification": {
          "unsupportedCodeLanguage": "Unsupported code language."
        }
      },
      "htmlRenderer": {
        "placeholder": {
          "failedToRenderHtml": "Error: Failed to render HTML. Value is not a string."
        }
      },
      "priceRenderer": {
        "title": "Price for sale",
        "label": {
          "priceInnerRecordHandling": "Price inner record handling"
        },
        "notification": {
          "invalidPricesObject": "Invalid prices object!"
        },
        "filter": {
          "label": {
            "priceId": "Price ID",
            "priceList": "Price list",
            "currency": "Currency",
            "innerRecordIds": "Inner record IDs"
          },
          "help": {
            "computePriceForSale": "No price for sale found. To compute price for sale, following constraints need to be present in the filter: `priceInPriceLists`, `priceInCurrency`.",
            "missingPriceListsAndCurrencyForPriceForSale": "To compute a price for sale for the filtered prices, select at least one price list and one currency.",
            "noPriceForSale": {
              "text": "No price for sale was computed for the filtered prices because {reason}.",
              "reason": {
                "noPrices": "there are no prices left for this filter",
                "noPriceLists": "no price lists are selected",
                "noCurrency": "no currency is selected",
                "tooManyCurrencies": "more than one currency is selected"
              }
            },
            "priceListOrder": "The order of selected price lists <em>defines the price listing ordering</em>.<br/>It also <em>defines priority</em> of price lists for price for sale computation."
          }
        },
        "price": {
          "label": {
            "priceId": "Price ID",
            "priceList": "Price list",
            "currency": "Currency",
            "innerRecordId": "Inner record ID",
            "sellable": "Sellable",
            "validity": "Validity",
            "priceWithoutTax": "Price without tax",
            "priceWithTax": "Price with tax",
            "taxRate": "Tax rate",
            "virtual": "Virtual"
          },
          "tooltip": {
            "sellablePrice": "This price is sellable.",
            "notSellablePrice": "This price is not sellable."
          },
          "help": {
            "priceForSale": "This price would be used as a price for sale if this filter were used in the main query.",
            "virtualPriceForSale": "This is a virtual price for sale computed based on this filter. The price is virtual because the entity has price inner record handling set to `SUM`, therefore, the price for sale is a sum of internally selected prices."
          }
        }
      },
      "referenceAttributeRenderer": {
        "button": {
          "openReference": "Open reference in new tab"
        }
      }
    }
  },
  "errorViewer": {
    "title": "Error: {name}",
    "placeholder": {
      "noDetailsAvailable": "No details available."
    },
    "button": {
      "submitIssue": "Submit an issue"
    }
  },
  "evitaQLConsole": {
    "placeholder": {
      "writeQuery": "// Write your EvitaQL query for catalog {catalogName} here.\n",
      "results": "Results will be displayed here..."
    },
    "notification": {
      "failedToSaveQueryToHistory": "Failed to save query to history."
    }
  },
  "graphQLConsole": {
    "instanceType": {
      "system": "System",
      "data": "Data",
      "schema": "Schema"
    },
    "placeholder": {
      "writeQuery": "# Write your GraphQL query for catalog {catalogName} here.\n",
      "results": "Results will be displayed here..."
    },
    "button": {
      "instanceDetails": "GraphQL API instance details"
    },
    "notification": {
      "failedToSaveQueryToHistory": "Failed to save query to history."
    }
  },
  "historyComponent": {
    "button": {
      "clearHistory": "Clear history"
    },
    "placeholder": {
      "emptyHistory": "Empty history"
    }
  },
  "resultVisualizer": {
    "selector": {
      "label": {
        "query": "From",
        "data": "Visualise"
      }
    },
    "visualiser": {
      "placeholder": {
        "noQueries": "No queries to visualise",
        "noSelectedQuery": "Select query to visualise",
        "noSelectedData": "Select what to visualise"
      }
    },
    "facetStatisticsVisualiser": {
      "placeholder": {
        "noGroups": "No facet summary groups found."
      },
      "label": {
        "externalGroup": "External",
        "externalReference": "External"
      },
      "notification": {
        "primaryKeyCopiedToClipboard": "Primary key copied to clipboard.",
        "noPrimaryKeyProperty": "No primary key property was fetched."
      },
      "help": {
        "noPrimaryKeyProperty": "No `primaryKey` property or representative attributes were fetched.",
        "noGroupCountProperty": "No `count` property was fetched.",
        "groupCountProperty": "The total number of entities matching any facet from this group without user filter.",
        "externalGroup": "This is only a reference to an external entity that is managed by external system.",
        "noRequestedProperty": "The `requested` property was not fetched.",
        "noRepresentativeProperty": "No `primaryKey` property or representative attributes were fetched.",
        "zeroImpactMatchCount": "No entities would be returned if this facet was requested because no entity has combination of already requested facets plus this one.",
        "noTotalRecordCountProperty": "The `totalRecordCount` property was not found in neither `recordPage` nor `recordStrip`.",
        "totalRecordCountProperty": "The total number of entities matching the user filter.",
        "noImpactDifferenceProperty": "The `impact.difference` property was not found.",
        "impactDifferenceProperty": "The difference from the current number of entities matching the user filter if this facet was requested.",
        "noImpactMatchProperty": "The `impact.matchCount` property was not found.",
        "impactMatchProperty": "The total number of entities matching the user filter if this facet was requested.",
        "noCountProperty": "The `count` property was not found.",
        "countProperty": "The total number of entities matching this facet without the user filter.",
        "externalReference": "This is only a reference to an external entity that is managed by external system."
      }
    },
    "hierarchyVisualiser": {
      "placeholder": {
        "noHierarchies": "No hierarchies found."
      },
      "label": {
        "requested": "Requested",
        "unknown": "Unknown"
      },
      "notification": {
        "primaryKeyCopiedToClipboard": "Primary key copied to clipboard.",
        "noPrimaryKeyProperty": "No primary key property was fetched.",
        "parentPrimaryKeyCopiedToClipboard": "Parent primary key copied to clipboard.",
        "noParentPrimaryKeyProperty": "No parent primary key property was fetched."
      },
      "help": {
        "noRepresentativeProperty": "No `primaryKey` property or representative attributes were fetched.",
        "requestedEntity": "The entity representing this hierarchy node was filtered by `hierarchyWithin`.",
        "noChildrenCountProperty": "The `childrenCount` property was not found.",
        "childrenCountProperty": "The count of child hierarchy nodes that exist in the hierarchy tree below the given node; the count is correct regardless of whether the children themselves are requested/traversed by the constraint definition, and respects hierarchyOfReference settings for automatic removal of hierarchy nodes that would contain empty result set of queried entities (REMOVE_EMPTY).",
        "noQueriedEntityCountProperty": "The `queriedEntityCount` property was not found.",
        "queriedEntityCountProperty": "The total number of queried entities that will be returned if the current query is focused on this particular hierarchy node using the hierarchyWithin filter constraint (the possible refining constraint in the form of directRelation and excludingRoot is not taken into account).",
        "nodeCountProperty": "The number of actually fetched nodes.",
        "requestedNode": "An entity representing a hierarchy node in this tree that was filtered by `hierarchyWithin`."
      }
    },
    "histogram": {
      "placeholder": {
        "unknown": "unknown",
        "missingPropertiesForChart": "Missing properties: {properties}. Cannot render the chart.",
        "missingProperties": "Missing properties: {properties}.",
        "missingPropertiesForSimulatedRange": "Missing properties: {properties}. Cannot simulate the range.",
        "missingPropertiesForActualRange": "Missing properties {properties} for actual values. The range is only simulated from indexes."
      },
      "label": {
        "allBuckets": "All buckets",
        "requestedBuckets": "Requested buckets",
        "overallCount": "Overall count",
        "bucketIndex": "Bucket index",
        "occurrences": "Occurrences",
        "threshold": "Threshold",
        "wasRequested": "Was requested"
      },
      "help": {
        "noMinProperty": "No `min` property of the histogram was fetched.",
        "noOverallCountProperty": "No `overallCount` property of the histogram was fetched.",
        "noMaxProperty": "No `max` property of the histogram was fetched."
      }
    },
    "attributeHistogram": {
      "placeholder": {
        "noAttributeHistograms": "No attribute histograms found."
      }
    },
    "priceHistogram": {
      "placeholder": {
        "noPriceHistograms": "No price histogram found."
      }
    }
  },
  "schemaViewer": {
    "title": {
      "schema": {
        "entity": "Entities",
        "attribute": "Attributes",
        "associatedData": "Associated data",
        "reference": "References",
        "sortableAttributeCompounds": "Sortable attribute compounds"
      }
    },
    "path": {
      "item": {
        "entities": "entities",
        "attributes": "attributes",
        "associatedData": "associated data",
        "references": "references"
      }
    },
    "section": {
      "placeholder": {
        "noItemsForSearchedTerm": "No items found for searched term."
      },
      "label": {
        "filter": "Filter"
      },
      "flag": {
        "attributeElement": {
          "nullsFirst": "nulls first",
          "nullsLast": "nulls last",
          "asc": "ascending",
          "desc": "descending",
          "reflected": "reflected"
        },
        "entitySchema": {
          "hierarchical": "hierarchical"
        },
        "attributeSchema": {
          "representative": "representative",
          "globallyUnique": "globally unique",
          "globallyUniquePerLocale": "globally unique per locale",
          "unique": "unique",
          "uniquePerLocale": "unique per locale",
          "filterable": "filterable",
          "sortable": "sortable",
          "localized": "localized",
          "nullable": "nullable",
          "attributeTooltip": "The attribute can be filtered/sorted within the live/archive scope."
        },
        "associatedDataSchema": {
          "localized": "localized",
          "nullable": "nullable"
        },
        "referenceSchema": {
          "external": "external",
          "indexed": "indexed",
          "faceted": "faceted"
        },
        "reflectedReferenceSchema": {
          "reflectedReference": "reflected"
        }
      }
    },
    "catalog": {
      "label": {
        "catalogId": "Catalog ID",
        "version": "Version",
        "description": "Description",
        "locales": "Locales"
      }
    },
    "entities": {
      "title": "Entities"
    },
    "sortableAttributeCompounds": {
      "title": "Sortable attribute compounds"
    },
    "entity": {
      "label": {
        "version": "Version",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "locales": "Locales",
        "currencies": "Currencies",
        "generatedPrimaryKey": "Generated primary key",
        "hierarchical": "Hierarchical",
        "prices": "Prices",
        "indexedDecimalPlaces": "Indexed decimal places",
        "evolutionModes": "Evolution modes"
      },
      "evolutionMode": {
        "adaptPrimaryKeyGeneration": "Adapt Primary Key Generation",
        "addingAttributes": "Adding Attributes",
        "addingAssociatedData": "Adding Associated Data",
        "addingReferences": "Adding References",
        "addingPrices": "Adding Prices",
        "addingLocales": "Adding Locales",
        "addingCurrencies": "Adding Currencies",
        "addingHierarchy": "Adding Hierarchy"
      }
    },
    "nameVariants": {
      "title": "Name variants",
      "prefixedTitle": "{prefix} name variants",
      "label": {
        "camelCase": "camelCase",
        "kebabCase": "kebab-case",
        "pascalCase": "PascalCase",
        "snakeCase": "snake_case",
        "upperSnakeCase": "UPPER_SNAKE_CASE"
      }
    },
    "attributes": {
      "title": "Attributes"
    },
    "attribute": {
      "placeholder": {
        "uniqueWithinCollection": "Within collection",
        "uniqueWithinLocaleOfCollection": "Within locale of collection",
        "globallyUniqueWithinCatalog": "Within catalog",
        "globallyUniqueWithinLocaleOfCatalog": "Within locale of catalog"
      },
      "label": {
        "live": "In Live scope",
        "archive": "In Archive scope",
        "type": "Type",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "representative": "Representative",
        "unique": "Unique",
        "globallyUnique": "Globally unique",
        "filterable": "Filterable",
        "sortable": "Sortable",
        "filtered": "filtered",
        "filteredDueToUnique": "due to uniqueness",
        "sorted": "sorted",
        "localized": "Localized",
        "nullable": "Nullable",
        "defaultValue": "Default value",
        "indexedDecimalPlaces": "Indexed decimal places",
        "attributes": "Attributes",
        "uniqueWithinCollection": "within collection",
        "uniqueWithinLocaleOfCollection": "within locale of collection"
      },
      "tooltip": {
        "content": "The attribute can be {0} within the {1} scope.",
        "contentNegation": "The attribute cannot be {0} within the {1} scope.",
        "uniqueContent": "The attribute {0} in {1} scope.",
        "referenceAttributeContent": "Attribute {0} is present in {1} scope.",
        "filterableUnique": "In live scope (due to uniqueness)",
        "uniquePer": ""
      },
      "help": {
        "uniqueWithinCollection": "The attribute value must be unique among all the entities of the same collection. The {0} attribute is present in scope {1}.",
        "uniqueWithinLocaleOfCollection": "The localized attribute value must be unique among all values of the same locale among all the entities. The {0} attribute is present in scope {1}.",
        "globallyUniqueWithinCatalog": "The attribute value (either localized or non-localized) must be unique among all values among all the entities using this global attribute schema in the entire catalog. The {0} attribute is present in scope {1}.",
        "globallyUniqueWithinLocaleOfCatalog": "The localized attribute value must be unique among all values of the same locale among all the entities using this global attribute schema in the entire catalog. The {0} attribute is present in scope {1}.",
        "implicitlyFilterable": "The attribute is implicitly filterable because it is unique."
      }
    },
    "associatedData": {
      "title": "Associated data"
    },
    "associatedDatum": {
      "label": {
        "type": "Type",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "localized": "Localized",
        "nullable": "Nullable"
      }
    },
    "references": {
      "title": "References"
    },
    "reference": {
      "label": {
        "live": "In Live scope",
        "archive": "In Archive scope",
        "description": "Description",
        "deprecationNotice": "Deprecation notice",
        "cardinality": "Cardinality",
        "referencedEntity": "Referenced entity",
        "referencedEntityManaged": "Referenced entity managed",
        "referencedGroup": "Referenced group",
        "faceted": "Faceted",
        "referencedEntityNameVariants": "Referenced entity",
        "referencedGroupNameVariants": "Referenced group",
        "indexed": {
          "title": "Indexed",
          "none": "None",
          "forFiltering": "For filtering",
          "forFilteringAndPartitioning": "For filtering and partitioning"
        },
        "reflectedReference": "Reflects",
        "inherited": "inherited",
        "groupManagedByEvita": "This referenced group is managed by EvitaDB.",
        "groupManagedExternal": "This referenced group is managed externally."
      },
      "tooltip": {
        "content": "The reference is {0} indexed within the {1} scope.",
        "facetedContent": "The reference {0} provide facets within the {1} scope.",
        "indexedTooltip": {
          "none": "Reference has no index available.",
          "forFiltering": "Reference has only basic index available that is necessary for ReferenceHaving constraint interpretation.",
          "forFilteringAndPartitioning": "Reference has basic index available and also partitioning indexes for the main entity type."
        },
        "faceted": "Special facet index is maintained for this reference allowing interpretation of FacetHaving filtering and FacetSummary requirement constraints."
      },
      "reflected": {
        "reflectedReferences": "Reflected by"
      }
    },
    "sortableAttributeCompound": {
      "name": "Sortable attribute compound",
      "label": {
        "name": "Name",
        "deprecationNotice": "Deprecation notice",
        "description": "Description"
      },
      "attributeElement": {
        "title": "Attribute elements"
      }
    },
    "tooltip": {
      "live": "live",
      "archive": "archive",
      "filtered": "filtered",
      "sorted": "sorted",
      "doesNot": "doesn't",
      "not": "not",
      "unique": "unique",
      "liveContent": "The default scope is where all new entities are created.",
      "archiveContent": "The archive scope is where outdated entities that are no longer actively used are stored. The archive is usually covered by fewer indexes than the live scope and is not searched unless explicitly requested in a query."
    }
  },
  "serverViewer": {
    "definition": {
      "title": "Server"
    },
    "title": "Server",
    "button": {
      "reload": "Reload"
    },
    "notification": {
      "couldNotLoad": "Could not load server status: {reason}"
    },
    "serverTitle": {
      "flags": {
        "version": "version: {version}",
        "readOnly": "read only"
      }
    },
    "serverStatus": {
      "title": "Status",
      "stats": {
        "started": "Started",
        "uptime": "Uptime",
        "readiness": {
          "label": "Readiness",
          "type": {
            "starting": "starting",
            "ready": "ready",
            "stalling": "stalling",
            "shutdown": "shutdown",
            "unknown": "unknown"
          }
        },
        "catalogsOk": "Catalogs",
        "catalogsCorrupted": "Corrupted catalogs",
        "healthProblems": {
          "label": "Health problems",
          "type": {
            "memoryShortage": "memory shortage",
            "externalApiUnavailable": "external API unavailable",
            "inputQueuesOverloaded": "input queues overloaded",
            "javaInternalErrors": "Java internal errors"
          }
        }
      },
      "apiType": {
        "system": "System",
        "grpc": "gRPC",
        "graphQL": "GraphQL",
        "rest": "REST",
        "observability": "Observability",
        "lab": "evitaLab"
      },
      "apiState": {
        "disabled": "API is disabled",
        "notReady": "API is not ready",
        "ready": "API is ready"
      },
      "button": {
        "openRuntimeConfiguration": "Runtime configuration",
        "openApiDetail": "API detail"
      },
      "apiDetail": {
        "title": "{apiType} API",
        "props": {
          "enabled": "Enabled",
          "ready": "Ready",
          "baseUrls": "Base URLs"
        },
        "endpoints": {
          "title": "Endpoints"
        }
      },
      "runtimeConfiguration": {
        "title": "Runtime configuration",
        "notification": {
          "couldNotLoadConfiguration": "Could not load runtime configuration: {reason}"
        }
      }
    }
  },
  "backupViewer": {
    "backupSelector": {
      "currentSnapshot": "Current snapshot",
      "pointInTime": "Point in time",
      "fullBackup": "Full",
      "selectSubTitle": "Choose backup type"
    },
    "definition": {
      "title": "Catalog backups"
    },
    "title": "Catalog backups",
    "button": {
      "reloadBackups": "Reload backups",
      "restoreLocalBackup": "Import and restore catalog from backup file",
      "backupCatalog": "Backup catalog"
    },
    "tasks": {
      "title": "Backups in preparation"
    },
    "list": {
      "title": "Available backups",
      "noFiles": "No catalog backups are available",
      "backup": {
        "button": {
          "restoreBackupFile": "Restore backup file"
        }
      }
    },
    "notification": {
      "couldNotLoadBackupFiles": "Could not load backup files: {reason}",
      "couldNotDownloadBackupFile": "Could not download backup file {fileName}: {reason}"
    },
    "backup": {
      "title": "Backup catalog",
      "info": "The back up process may take a while. Therefore it will be started asynchronously. You can find it‚Äôs progress and backup file to download in task listing.",
      "form": {
        "catalogName": {
          "label": "Catalog to backup",
          "validations": {
            "required": "Catalog to backup is required.",
            "notExists": "Selected catalog doesn't exist anymore."
          }
        },
        "pastMoment": {
          "label": "Past moment"
        },
        "includeWal": {
          "label": "Include WAL",
          "description": "Will apply all mutations from WAL during restoration resulting in the latest version of catalog"
        }
      },
      "full": {
        "title": "Full backup",
        "description": "A full backup will contain a binary copy of all catalog files at the current time. After restoring the catalog from this backup, it will also be possible to perform additional \"point-in-time\" backups from this restored copy for all moments for which historical data is available. This full backup is the largest backup of the catalog in size.\n"
      },
      "pointInTime": {
        "title": "Point in time backup",
        "description": "A point in time backup contains only data valid at the point in time (version) of the catalog that is selected when the backup is created. When going back in time, it is only possible to select a point in time for which the database still has historical data. In order to protect against running out of disk capacity, historical data is deleted after some time / reaching a limit size. A catalog restored from this backup will not allow point in time recovery, or will only allow it over other write operations performed over the restored catalog."
      },
      "snapshot": {
        "title": "Current snapshot backup",
        "description": "The current snapshot contains only currently valid data. It is the smallest possible functional backup, which also makes it the fastest backup option. A catalog restored from this backup will not allow point-in-time recovery, or will only allow recovery over other write operations performed on the restored catalog."
      },
      "button": {
        "backup": "Backup"
      },
      "notification": {
        "couldNotLoadAvailableCatalogs": "Could not load available catalogs: {reason}",
        "couldNotLoadMinimalDate": "Could not load available moments: {reason}",
        "backupRequested": "A backup for the {catalogName} catalog requested.",
        "couldNotRequestBackup": "Could not request a backup for the {catalogName} catalog: {reason}"
      },
      "description": "Request a new backup for the catalog:"
    },
    "restore": {
      "title": "Restore catalog from {fileName}",
      "description": "Request restoration of the backup file into catalog:",
      "info": "The restore process may take a while. Therefore, it will be started asynchronously. You can find it's progress in backups or tasks.",
      "button": {
        "restore": "Restore"
      },
      "form": {
        "catalogName": {
          "label": "Catalog name",
          "validations": {
            "required": "Catalog name is required.",
            "empty": "Catalog name is required.",
            "leadingTrailingWhiteSpace": "Catalog name cannot have leading or trailing whitespace characters.",
            "keyword": "Catalog name is same as a reserved keyword.",
            "format": "Catalog name doesn't match supported format.",
            "notAvailable": "Catalog with this name already exists."
          }
        }
      },
      "notification": {
        "restoreRequested": "A restoration of the {fileName} backup file has been requested.",
        "couldNotRestoreBackupFile": "Could not restore backup file {fileName}: {reason}"
      }
    },
    "restoreLocal": {
      "title": "Restore catalog",
      "description": "Request restoration of imported backup file into catalog:",
      "info": "The restore process may take a while. Therefore, it will be started asynchronously. You can find it's progress in backups or tasks.",
      "button": {
        "restore": "Restore"
      },
      "form": {
        "backupFile": {
          "label": "Backup file",
          "validations": {
            "required": "Backup file is required."
          }
        },
        "catalogName": {
          "label": "Catalog name",
          "validations": {
            "required": "Catalog name is required.",
            "empty": "Catalog name is required.",
            "leadingTrailingWhiteSpace": "Catalog name cannot have leading or trailing whitespace characters.",
            "keyword": "Catalog name is same as a reserved keyword.",
            "format": "Catalog name doesn't match supported format.",
            "notAvailable": "Catalog with this name already exists."
          }
        }
      },
      "notification": {
        "restoreRequested": "A backup restoration has been requested.",
        "couldNotRestoreBackupFile": "Could not restore backup file: {reason}"
      }
    }
  },
  "taskViewer": {
    "definition": {
      "title": "Tasks"
    },
    "title": "Tasks",
    "tasksVisualizer": {
      "button": {
        "reload": "Reload tasks"
      },
      "noTasks": "No tasks are running",
      "task": {
        "state": {
          "waitingForPrecondition": "waiting for precondition",
          "queued": "queued",
          "running": "running",
          "finished": "finished",
          "failed": "failed"
        },
        "trait": {
          "canBeStarted": "can be started",
          "canBeCancelled": "can be cancelled",
          "needsToBeStopped": "needs to be stopped"
        },
        "button": {
          "details": "Details",
          "downloadFileResult": "Download result",
          "textResult": "Result",
          "exception": "Exception",
          "cancel": "Forcefully cancel task"
        },
        "progress": {
          "indeterminate": "running..."
        },
        "detail": {
          "title": "Task",
          "property": {
            "id": "ID",
            "types": "Types",
            "name": "Name",
            "state": "State",
            "catalogName": "Catalog name",
            "created": "Created",
            "issued": {
              "label": "Issued",
              "notIssued": "<task hasn't yet been issued>"
            },
            "started": {
              "label": "Started",
              "notStarted": "<task hasn't yet been started>"
            },
            "finished": {
              "label": "Finished",
              "notStarted": "<task hasn't yet been started>",
              "notFinished": "<task hasn't yet been finished>"
            },
            "duration": {
              "label": "Duration",
              "notStarted": "<task hasn't yet been started>"
            },
            "progress": "Progress",
            "settings": "Settings",
            "traits": "Traits"
          }
        },
        "textResult": {
          "title": "Task result"
        },
        "exception": {
          "title": "Task exception"
        },
        "notification": {
          "couldNotDownloadResultFile": "Could not download result file for task {taskName}: {reason}"
        }
      },
      "notification": {
        "couldNotLoadTaskStatuses": "Could not load task statuses: {reason}",
        "taskCancelled": "The {taskName} task has been cancelled.",
        "taskNotCancelled": "The {taskName} task has not been cancelled. Probably because it is already finished",
        "couldNotCancelTask": "Could not cancel the {taskName} task: {reason}"
      }
    }
  },
  "jfrViewer": {
    "definition": {
      "title": "JFR Recordings"
    },
    "title": "JFR Recordings",
    "button": {
      "startRecording": "Start recording",
      "reloadRecordings": "Reload recordings"
    },
    "tasks": {
      "title": "Running recordings",
      "button": {
        "stopRecording": "Stop recording"
      }
    },
    "list": {
      "title": "Finished recordings",
      "noRecordings": "No JFR recordings are available"
    },
    "notification": {
      "couldNotLoadRecordings": "Could not load JFR recording files: {reason}",
      "couldNotDownloadRecordingFile": "Could not download JFR recording file {fileName}: {reason}"
    },
    "startRecording": {
      "title": "Start JFR recording",
      "info": "This will start recording process in background which will be active until you stop it manually. Note that there can be only one recording active at the same time.",
      "form": {
        "events": {
          "label": "Events to record",
          "validations": {
            "required": "Events are required."
          }
        }
      },
      "button": {
        "startRecording": "Start recording"
      },
      "notification": {
        "couldNotLoadEventTypes": "Could not load available event types for JFR recording: {reason}",
        "couldNotStartRecording": "Could not start JFR recording: {reason}",
        "recordingStarted": "JFR recording has been started.",
        "recordingNotStarted": "JFR recording has not been started."
      }
    },
    "stopRecording": {
      "title": "Stop JFR recording",
      "info": "This will stop the active recording process. The final recording will be available in the JFR recording listing.",
      "button": {
        "stopRecording": "Stop recording"
      },
      "notification": {
        "couldNotStopRecording": "Could not stop JFR recording: {reason}",
        "recordingStopped": "JFR recording has been stopped.",
        "recordingNotStopped": "JFR recording has not been stopped."
      }
    }
  },
  "serverFileViewer": {
    "list": {
      "item": {
        "button": {
          "deleteFile": "Delete server file",
          "downloadFile": "Download server file"
        },
        "notification": {
          "couldNotDownloadFile": "Could not download {fileName} file: {reason}"
        }
      }
    },
    "delete": {
      "title": "Delete {fileName} file",
      "question": "Do you want to delete server file?",
      "notification": {
        "fileDeleted": "The {fileName} file has been successfully deleted.",
        "fileNotDeleted": "The {fileName} file has not been deleted.",
        "couldNotDeleteFile": "Could not delete the {fileName} file: {reason}"
      }
    }
  },
  "trafficViewer": {
    "recordings": {
      "definition": {
        "title": "Traffic Recordings"
      },
      "title": "Traffic Recordings",
      "button": {
        "startRecording": "Start recording",
        "reloadRecordings": "Reload recordings"
      },
      "tasks": {
        "title": "Running recordings",
        "button": {
          "stopRecording": "Stop recording"
        }
      },
      "list": {
        "title": "Finished recordings",
        "noRecordings": "No traffic recordings are available"
      },
      "notification": {
        "couldNotLoadRecordings": "Could not load traffic recording files: {reason}",
        "couldNotDownloadRecordingFile": "Could not download traffic recording file {fileName}: {reason}"
      },
      "startRecording": {
        "title": "Start traffic recording",
        "info": "This will start recording process in background which will be active until you stop it manually or is stopped automatically by defined limits. Note that there can be only one recording active at the same time.",
        "infoForFileExport": "Once the recording process is finished, a file will be created and be ready for download.",
        "button": {
          "startRecording": "Start recording"
        },
        "form": {
          "catalogName": {
            "label": "Catalog to record",
            "validations": {
              "required": "Catalog to record is required.",
              "notExists": "Selected catalog doesn't exist anymore."
            }
          },
          "samplingRate": {
            "label": "Sampling rate",
            "hint": "The sampling rate of the traffic recording (100 % means all records will be recorded, 1 % means 1 % of records will be recorded).",
            "unit": "%",
            "validations": {
              "required": "Sampling rate is required.",
              "notNumber": "Sampling rate must be integer number.",
              "outOfRange": "Sampling rate must be number between 1 and 100 (inclusive)."
            }
          },
          "maxDurationInMilliseconds": {
            "label": "Maximum duration",
            "hint": "The duration of the recording, after this time the recording will be stopped automatically. Use combination of h, min, s, or ms units.",
            "validations": {
              "notDuration": "Maximum duration must be duration string.",
              "outOfRange": "Maximum duration must be positive number and less than 2^63-1 in milliseconds."
            }
          },
          "exportFile": {
            "label": "Export to file",
            "hint": "Whether to export the traffic into a file for download once the recording is finished."
          },
          "maxFileSizeInBytes": {
            "label": "Maximum file size",
            "hint": {
              "default": "The size of the recording in bytes, after this size the recording will be stopped automatically. You can use k, M, G, Ki, Mi, or Gi unit prefix.",
              "rounded": "The size of the recording will be rounded to full bytes."
            },
            "unit": "bytes",
            "validations": {
              "notByteSize": "Maximum file size must be byte size.",
              "outOfRange": "Maximum file size must be positive number and less than 2^63-1."
            }
          },
          "chunkFileSizeInBytes": {
            "label": "Chunk file size",
            "hint": {
              "default": "The size of the chunk file in bytes. Individual files in the export file will be approximately this size. You can use k, M, G, Ki, Mi, or Gi unit prefix.",
              "rounded": "The size of the chunk file will be rounded to full bytes."
            },
            "unit": "bytes",
            "validations": {
              "notByteSize": "Chunk file size must be byte size.",
              "outOfRange": "Chunk file size must be positive number and less than 2^63-1."
            }
          }
        },
        "notification": {
          "couldNotStartRecording": "Could not start traffic recording: {reason}",
          "recordingStarted": "Traffic recording has been started."
        }
      },
      "stopRecording": {
        "title": "Stop traffic recording",
        "info": "This will stop the active recording process. The final recording will be available in the traffic recording listing.",
        "button": {
          "stopRecording": "Stop recording"
        },
        "notification": {
          "couldNotStopRecording": "Could not stop traffic recording: {reason}",
          "recordingStopped": "Traffic recording has been stopped."
        }
      }
    },
    "recordHistory": {
      "title": "Active traffic recording",
      "notification": {
        "couldNotLoadRecords": "Could not load traffic records: {reason}",
        "couldNotLoadLatestRecording": "Could not load latest traffic record: {reason}"
      },
      "button": {
        "reloadRecordHistory": "Reload record history",
        "moveStartPointerToNewest": "Load only records newer than now",
        "removeStartPointer": "Load entire record history",
        "modifyStartPointer": "Change start of loaded record history"
      },
      "filter": {
        "label": "Filter",
        "form": {
          "since": {
            "label": "Since",
            "hint": "Specifies the time from which the history should be returned."
          },
          "types": {
            "label": "Types",
            "valueDescriptor": "{count} types selected",
            "hint": "Specifies the types of records to be returned.",
            "type": {
              "session": "Session",
              "sourceQuery": "Source query",
              "query": "Query",
              "fetch": "Fetch",
              "enrichment": "Enrichment",
              "mutation": "Mutation"
            }
          },
          "sessionId": {
            "label": "Session ID",
            "hint": "Specifies the session ID from which the history should be returned.",
            "validations": {
              "notUuid": "Session ID must be a UUID."
            }
          },
          "longerThan": {
            "label": "Longer than",
            "hint": "Specifies the minimum duration in milliseconds of the traffic recording to be returned. Use combination of h, min, s, or ms units.",
            "validations": {
              "notNumber": "Threshold must be a duration.",
              "outOfRange": "Threshold must be positive number and less than 2^53-1."
            }
          },
          "fetchingMoreBytesThan": {
            "label": "Fetching more bytes than",
            "hint": "Specifies the minimum number of bytes that record should have fetched from the disk. You can use k, M, G, Ki, Mi, or Gi unit prefix.",
            "unit": "bytes",
            "validations": {
              "notByteSize": "Threshold must be byte size.",
              "outOfRange": "Threshold must be positive number and less than 2^53-1."
            }
          },
          "labels": {
            "label": "Labels",
            "hint": "Specifies the client labels that the record must have (both name and value must match).",
            "displayedLabels": "no labels | 1 label | {count} labels",
            "form": {
              "newLabelName": "Name",
              "newLabelValue": "Value"
            },
            "button": {
              "addLabel": "Add label"
            }
          }
        },
        "button": {
          "apply": "Apply filter"
        },
        "notification": {
          "invalidFilter": "Filter criteria are not valid."
        }
      },
      "list": {
        "info": {
          "noActiveTrafficRecording": "There is no active traffic recording for the {catalogName} catalog. You need to either enable traffic recording on server options or start recording on demand in traffic recordings.",
          "indexCreating": "Index is being created for the active traffic recording for the {catalogName} catalog. Please wait and reload history in a few moments.",
          "noRecords": "There are no traffic records for defined filter."
        },
        "button": {
          "loadMore": "Load more"
        },
        "notification": {
          "noNewerRecords": "No newer records exist."
        }
      },
      "record": {
        "type": {
          "common": {
            "metadata": {
              "group": {
                "default": "Default metadata"
              },
              "item": {
                "sessionId": {
                  "tooltip": "Session ID under which the record was created",
                  "notification": {
                    "copiedToClipboard": "Session ID has been copied to clipboard"
                  }
                },
                "created": {
                  "tooltip": "Record creation time",
                  "notification": {
                    "copiedToClipboard": "Date time of record creation has been copied to clipboard"
                  }
                },
                "duration": "Record processing duration",
                "ioFetchedSizeBytes": {
                  "tooltip": "Number of bytes read from disk",
                  "value": "0 bytes fetched | 1 byte fetched | {count} fetched"
                },
                "ioFetchCount": {
                  "tooltip": "Number of I/O accesses to disk",
                  "value": "{count} disk accesses"
                },
                "finishedStatus": {
                  "tooltip": {
                    "success": "Record finished status",
                    "error": "Record finished status: {error}"
                  },
                  "status": {
                    "success": "Success",
                    "error": "Error"
                  }
                },
                "noStatistics": {
                  "tooltip": "No final statistics where fetched, therefore some useful data are not displayed. Try fetching more records.",
                  "title": "No statistics"
                }
              }
            }
          },
          "sessionStart": {
            "label": "Session start",
            "title": "Session",
            "action": {
              "open": "Open traffic recording for this session"
            }
          },
          "sessionClose": {
            "label": "Session close",
            "metadata": {
              "item": {
                "catalogVersion": "Used catalog version",
                "trafficRecordCount": {
                  "tooltip": "Traffic record count",
                  "value": "no traffic | 1 traffic record | {count} traffic records"
                },
                "queryCount": {
                  "tooltip": "Queries executed count",
                  "value": "no queries | 1 query | {count} queries"
                },
                "entityFetchCount": {
                  "tooltip": "Entities fetched count",
                  "value": "no entities | 1 entity | {count} entities"
                },
                "mutationCount": {
                  "tooltip": "Mutations executed count",
                  "value": "no mutations | 1 mutation | {count} mutations"
                }
              }
            }
          },
          "sourceQuery": {
            "label": "Source query",
            "title": "Source query: {queryType}",
            "metadata": {
              "group": {
                "queryLabels": "Query labels"
              },
              "item": {
                "queryLabel": "Query label"
              }
            },
            "action": {
              "query": "Open query in console"
            }
          },
          "sourceQueryStatistics": {
            "label": "Source query statistics",
            "metadata": {
              "item": {
                "returnedRecordCount": {
                  "tooltip": "Returned record count",
                  "value": "no records returned | 1 record returned | {count} records returned"
                },
                "totalRecordCount": {
                  "tooltip": "Total record count",
                  "value": "no records | 1 record total | {count} records total"
                }
              }
            }
          },
          "query": {
            "label": "Query",
            "title": "Query",
            "metadata": {
              "group": {
                "queryLabels": "Query labels"
              },
              "item": {
                "totalRecordCount": {
                  "tooltip": "Total record count",
                  "value": "no records | 1 record total | {count} records total"
                },
                "primaryKeys": {
                  "tooltip": "Actual returned records count",
                  "value": "no records returned | 1 record returned | {count} records returned"
                },
                "queryLabel": "Query label"
              }
            },
            "action": {
              "query": "Open query in console"
            }
          },
          "fetch": {
            "label": "Fetch",
            "title": "Entity {primaryKey} fetch",
            "action": {
              "query": "Open fetch query in console"
            }
          },
          "enrichment": {
            "label": "Enrichment",
            "title": "Entity {primaryKey} enrichment",
            "action": {
              "query": "Open enrichment query in console"
            }
          },
          "mutation": {
            "label": "Mutation"
          }
        }
      }
    }
  },
  "relationViewer": {
    "title": "Relation",
    "cardinality": {
      "exactlyOne": "1:1",
      "oneOrMore": "1:1‚Ä¶*",
      "zeroOrOne": "1:0‚Ä¶1",
      "zeroOrMore": "1:0‚Ä¶*"
    },
    "managedByEvita": "This entity is managed by evitaDB.",
    "managedExternal": "This entity is managed externally."
  }
}