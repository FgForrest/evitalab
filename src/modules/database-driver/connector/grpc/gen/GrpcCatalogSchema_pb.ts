// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file GrpcCatalogSchema.proto (package io.evitadb.externalApi.grpc.generated, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, StringValue } from "@bufbuild/protobuf";
import { GrpcAttributeUniquenessType, GrpcCatalogEvolutionMode, GrpcEntityScope, GrpcEvitaDataType, GrpcGlobalAttributeUniquenessType } from "./GrpcEnums_pb.js";
import { GrpcEvitaValue, GrpcNameVariant, GrpcScopedAttributeUniquenessType, GrpcScopedGlobalAttributeUniquenessType } from "./GrpcEvitaDataTypes_pb.js";

/**
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcCatalogSchema
 */
export class GrpcCatalogSchema extends Message<GrpcCatalogSchema> {
  /**
   * Contains unique name of the catalog. Case-sensitive. Distinguishes one catalog item from another
   * within single entity instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Contains version of this catalog schema and gets increased with any entity type update. Allows to execute
   * optimistic locking i.e. avoiding parallel modifications.
   *
   * @generated from field: int32 version = 2;
   */
  version = 0;

  /**
   * Contains description of the model is optional but helps authors of the schema / client API to better
   * explain the original purpose of the model to the consumers.
   *
   * @generated from field: google.protobuf.StringValue description = 3;
   */
  description?: string;

  /**
   * set of evolution modes that allow to specify how strict is evitaDB when unknown information is presented to her
   * for the first time. When no evolution mode is set, each violation of the catalog schema is
   * reported by an exception. This behaviour can be changed by this evolution mode, however.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcCatalogEvolutionMode catalogEvolutionMode = 4;
   */
  catalogEvolutionMode: GrpcCatalogEvolutionMode[] = [];

  /**
   * Contains index of generally (catalog-wide) shared `AttributeSchema` that could be used as attributes of any
   * entity type that refers them. These attributes cannot be changed from within the entity schema. Entity schemas
   * will not be able to define their own attribute of same name that would clash with the global one (they may only
   * reference the attributes with the same name from the catalog schema).
   *
   * There may be entities that won't take advantage of certain global attributes (i.e. it's not guaranteed that all
   * entity types in catalog have all global attributes).
   *
   * The "catalog-wide" unique attributes allows Evita to fetch entity of any (and up-front unknown) entity type by
   * some unique attribute value - usually URL.
   *
   * @generated from field: map<string, io.evitadb.externalApi.grpc.generated.GrpcGlobalAttributeSchema> attributes = 5;
   */
  attributes: { [key: string]: GrpcGlobalAttributeSchema } = {};

  /**
   * Contains catalog name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 6;
   */
  nameVariant: GrpcNameVariant[] = [];

  constructor(data?: PartialMessage<GrpcCatalogSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcCatalogSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "description", kind: "message", T: StringValue },
    { no: 4, name: "catalogEvolutionMode", kind: "enum", T: proto3.getEnumType(GrpcCatalogEvolutionMode), repeated: true },
    { no: 5, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GrpcGlobalAttributeSchema} },
    { no: 6, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcCatalogSchema {
    return new GrpcCatalogSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcCatalogSchema {
    return new GrpcCatalogSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcCatalogSchema {
    return new GrpcCatalogSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcCatalogSchema | PlainMessage<GrpcCatalogSchema> | undefined, b: GrpcCatalogSchema | PlainMessage<GrpcCatalogSchema> | undefined): boolean {
    return proto3.util.equals(GrpcCatalogSchema, a, b);
  }
}

/**
 * This is the definition object for attributes that are stored along with
 * catalog. Definition objects allow to describe the structure of the catalog so that
 * in any time everyone can consult complete structure of the catalog. Definition object is similar to Java reflection
 * process where you can also at any moment see which fields and methods are available for the class.
 *
 * Catalog attributes allows defining set of data that are fetched in bulk along with the catalog body.
 * Attributes may be indexed for fast filtering or can be used to sort along. Attributes are not automatically indexed
 * in order not to waste precious memory space for data that will never be used in search queries.
 *
 * Filtering in attributes is executed by using constraints like `and`, `or`, `not`. Sorting can be achieved with
 * `attributeNatural` or others.
 *
 * Attributes are not recommended for bigger data as they are all loaded at once when requested.
 *
 * @generated from message io.evitadb.externalApi.grpc.generated.GrpcGlobalAttributeSchema
 */
export class GrpcGlobalAttributeSchema extends Message<GrpcGlobalAttributeSchema> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * optional description of the attribute
   *
   * @generated from field: google.protobuf.StringValue description = 2;
   */
  description?: string;

  /**
   * optional deprecation notice
   *
   * @generated from field: google.protobuf.StringValue deprecationNotice = 3;
   */
  deprecationNotice?: string;

  /**
   * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
   * having certain value of this attribute among other entities in the same collection.
   *
   * As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
   * better to have this ensured by the database engine.
   * deprecated in favor of `uniqueInScopes`
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcAttributeUniquenessType unique = 4 [deprecated = true];
   * @deprecated
   */
  unique = GrpcAttributeUniquenessType.NOT_UNIQUE;

  /**
   * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
   * as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
   * (memory/disk) space in the form of index.
   *
   * When attribute is filterable, extra result `attributeHistogram`
   * can be requested for this attribute.
   * deprecated in favor of `filterableInScopes`
   *
   * @generated from field: bool filterable = 5 [deprecated = true];
   * @deprecated
   */
  filterable = false;

  /**
   * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
   * as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
   * (memory/disk) space in the form of index..
   * deprecated in favor of `sortableInScopes`
   *
   * @generated from field: bool sortable = 6 [deprecated = true];
   * @deprecated
   */
  sortable = false;

  /**
   * When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
   *
   * @generated from field: bool localized = 7;
   */
  localized = false;

  /**
   * When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce
   * non-null checks upon upserting of the entity.
   *
   * @generated from field: bool nullable = 8;
   */
  nullable = false;

  /**
   * If an attribute is flagged as representative, it should be used in developer tools along with the entity's
   * primary key to describe the entity or reference to that entity. The flag is completely optional and doesn't
   * affect the core functionality of the database in any way. However, if it's used correctly, it can be very
   * helpful to developers in quickly finding their way around the data. There should be very few representative
   * attributes in the entity type, and the unique ones are usually the best to choose.
   *
   * @generated from field: bool representative = 9;
   */
  representative = false;

  /**
   * Data type of the attribute. Must be one of Evita-supported values.
   * Internally the scalar is converted into Java-corresponding data type.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcEvitaDataType type = 10;
   */
  type = GrpcEvitaDataType.STRING;

  /**
   * Default value is used when the entity is created without this attribute specified. Default values allow to pass
   * non-null checks even if no attributes of such name are specified.
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcEvitaValue defaultValue = 11;
   */
  defaultValue?: GrpcEvitaValue;

  /**
   * Determines how many fractional places are important when entities are compared during filtering or sorting. It is
   * significant to know that all values of this attribute will be converted to {@link java.lang.Integer}, so the attribute
   * number must not ever exceed maximum limits of {@link java.lang.Integer} type when scaling the number by the power
   * of ten using `indexedDecimalPlaces` as exponent.
   *
   * @generated from field: int32 indexedDecimalPlaces = 12;
   */
  indexedDecimalPlaces = 0;

  /**
   * When attribute is unique globally it is automatically filterable, and it is ensured there is exactly one single
   * entity having certain value of this attribute in entire catalog.
   *
   * As an example of unique attribute can be URL - there is no sense in having two entities with same URL, and it's
   * better to have this ensured by the database engine.
   * deprecated in favor of `uniqueGloballyInScopes`
   *
   * @generated from field: io.evitadb.externalApi.grpc.generated.GrpcGlobalAttributeUniquenessType uniqueGlobally = 13 [deprecated = true];
   * @deprecated
   */
  uniqueGlobally = GrpcGlobalAttributeUniquenessType.NOT_GLOBALLY_UNIQUE;

  /**
   * Contains attribute name converted to different naming conventions.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcNameVariant nameVariant = 14;
   */
  nameVariant: GrpcNameVariant[] = [];

  /**
   * When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
   * having certain value of this attribute among other entities in the same collection.
   *
   * As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
   * better to have this ensured by the database engine.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcScopedAttributeUniquenessType uniqueInScopes = 15;
   */
  uniqueInScopes: GrpcScopedAttributeUniquenessType[] = [];

  /**
   * When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
   * as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
   * (memory/disk) space in the form of index.
   *
   * When attribute is filterable, extra result `attributeHistogram`
   * can be requested for this attribute.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcEntityScope filterableInScopes = 16;
   */
  filterableInScopes: GrpcEntityScope[] = [];

  /**
   * When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
   * as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
   * (memory/disk) space in the form of index..
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcEntityScope sortableInScopes = 17;
   */
  sortableInScopes: GrpcEntityScope[] = [];

  /**
   * When attribute is unique globally it is automatically filterable, and it is ensured there is exactly one single
   * entity having certain value of this attribute in entire catalog.
   *
   * As an example of unique attribute can be URL - there is no sense in having two entities with same URL, and it's
   * better to have this ensured by the database engine.
   *
   * @generated from field: repeated io.evitadb.externalApi.grpc.generated.GrpcScopedGlobalAttributeUniquenessType uniqueGloballyInScopes = 18;
   */
  uniqueGloballyInScopes: GrpcScopedGlobalAttributeUniquenessType[] = [];

  constructor(data?: PartialMessage<GrpcGlobalAttributeSchema>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.evitadb.externalApi.grpc.generated.GrpcGlobalAttributeSchema";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "message", T: StringValue },
    { no: 3, name: "deprecationNotice", kind: "message", T: StringValue },
    { no: 4, name: "unique", kind: "enum", T: proto3.getEnumType(GrpcAttributeUniquenessType) },
    { no: 5, name: "filterable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "sortable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "localized", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "representative", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "type", kind: "enum", T: proto3.getEnumType(GrpcEvitaDataType) },
    { no: 11, name: "defaultValue", kind: "message", T: GrpcEvitaValue },
    { no: 12, name: "indexedDecimalPlaces", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 13, name: "uniqueGlobally", kind: "enum", T: proto3.getEnumType(GrpcGlobalAttributeUniquenessType) },
    { no: 14, name: "nameVariant", kind: "message", T: GrpcNameVariant, repeated: true },
    { no: 15, name: "uniqueInScopes", kind: "message", T: GrpcScopedAttributeUniquenessType, repeated: true },
    { no: 16, name: "filterableInScopes", kind: "enum", T: proto3.getEnumType(GrpcEntityScope), repeated: true },
    { no: 17, name: "sortableInScopes", kind: "enum", T: proto3.getEnumType(GrpcEntityScope), repeated: true },
    { no: 18, name: "uniqueGloballyInScopes", kind: "message", T: GrpcScopedGlobalAttributeUniquenessType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcGlobalAttributeSchema {
    return new GrpcGlobalAttributeSchema().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcGlobalAttributeSchema {
    return new GrpcGlobalAttributeSchema().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcGlobalAttributeSchema {
    return new GrpcGlobalAttributeSchema().fromJsonString(jsonString, options);
  }

  static equals(a: GrpcGlobalAttributeSchema | PlainMessage<GrpcGlobalAttributeSchema> | undefined, b: GrpcGlobalAttributeSchema | PlainMessage<GrpcGlobalAttributeSchema> | undefined): boolean {
    return proto3.util.equals(GrpcGlobalAttributeSchema, a, b);
  }
}

